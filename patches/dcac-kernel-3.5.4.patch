diff -crN orig/linux-3.5.4/arch/x86/syscalls/syscall_64.tbl linux-3.5.4/arch/x86/syscalls/syscall_64.tbl
*** orig/linux-3.5.4/arch/x86/syscalls/syscall_64.tbl	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/arch/x86/syscalls/syscall_64.tbl	2014-01-20 15:45:10.349335931 -0600
***************
*** 320,325 ****
--- 320,330 ----
  311	64	process_vm_writev	sys_process_vm_writev
  312	common	kcmp			sys_kcmp
  
+ 320 common  dcac_add_ops    sys_dcac_add_ops
+ 321 common  dcac_acl_ops    sys_dcac_acl_ops
+ 322 common  dcac_mask_ops   sys_dcac_mask_ops
+ 323 common  dcac_info_ops   sys_dcac_info_ops
+ 
  #
  # x32-specific system call numbers start at 512 to avoid cache impact
  # for native 64-bit operation.
diff -crN orig/linux-3.5.4/fs/exec.c linux-3.5.4/fs/exec.c
*** orig/linux-3.5.4/fs/exec.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/exec.c	2014-01-20 15:45:10.349335931 -0600
***************
*** 66,71 ****
--- 66,75 ----
  
  #include <trace/events/sched.h>
  
+ #ifdef CONFIG_SECURITY_DCAC
+ #include "../security/dcac/include/dcac.h"
+ #endif
+ 
  int core_uses_pid;
  char core_pattern[CORENAME_MAX_SIZE] = "core";
  unsigned int core_pipe_limit;
***************
*** 1030,1036 ****
--- 1034,1045 ----
  		fdt->close_on_exec[j] = 0;
  		spin_unlock(&files->file_lock);
  		for ( ; set ; i++,set >>= 1) {
+ #ifdef CONFIG_SECURITY_DCAC
+             if ((set & 1) && fdt->fd[i] &&
+                     !DCAC_FLAGS_CAN_ADD(fdt->fd[i]->f_flags)) {
+ #else
  			if (set & 1) {
+ #endif
  				sys_close(i);
  			}
  		}
diff -crN orig/linux-3.5.4/fs/ext3/Makefile linux-3.5.4/fs/ext3/Makefile
*** orig/linux-3.5.4/fs/ext3/Makefile	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/ext3/Makefile	2014-01-20 15:48:09.265333670 -0600
***************
*** 7,12 ****
  ext3-y	:= balloc.o bitmap.o dir.o file.o fsync.o ialloc.o inode.o \
  	   ioctl.o namei.o super.o symlink.o hash.o resize.o ext3_jbd.o
  
! ext3-$(CONFIG_EXT3_FS_XATTR)	 += xattr.o xattr_user.o xattr_trusted.o
  ext3-$(CONFIG_EXT3_FS_POSIX_ACL) += acl.o
  ext3-$(CONFIG_EXT3_FS_SECURITY)	 += xattr_security.o
--- 7,12 ----
  ext3-y	:= balloc.o bitmap.o dir.o file.o fsync.o ialloc.o inode.o \
  	   ioctl.o namei.o super.o symlink.o hash.o resize.o ext3_jbd.o
  
! ext3-$(CONFIG_EXT3_FS_XATTR)	 += xattr.o xattr_user.o xattr_trusted.o xattr_nfsd.o
  ext3-$(CONFIG_EXT3_FS_POSIX_ACL) += acl.o
  ext3-$(CONFIG_EXT3_FS_SECURITY)	 += xattr_security.o
diff -crN orig/linux-3.5.4/fs/ext3/xattr.c linux-3.5.4/fs/ext3/xattr.c
*** orig/linux-3.5.4/fs/ext3/xattr.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/ext3/xattr.c	2014-01-20 15:48:09.265333670 -0600
***************
*** 109,114 ****
--- 109,115 ----
  #ifdef CONFIG_EXT3_FS_SECURITY
  	[EXT3_XATTR_INDEX_SECURITY]	     = &ext3_xattr_security_handler,
  #endif
+ 	[EXT3_XATTR_INDEX_NFSD]		     = &ext3_xattr_nfsd_handler,
  };
  
  const struct xattr_handler *ext3_xattr_handlers[] = {
***************
*** 121,126 ****
--- 122,128 ----
  #ifdef CONFIG_EXT3_FS_SECURITY
  	&ext3_xattr_security_handler,
  #endif
+ 	&ext3_xattr_nfsd_handler,
  	NULL
  };
  
diff -crN orig/linux-3.5.4/fs/ext3/xattr.h linux-3.5.4/fs/ext3/xattr.h
*** orig/linux-3.5.4/fs/ext3/xattr.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/ext3/xattr.h	2014-01-20 15:48:09.265333670 -0600
***************
*** 21,26 ****
--- 21,27 ----
  #define EXT3_XATTR_INDEX_TRUSTED		4
  #define	EXT3_XATTR_INDEX_LUSTRE			5
  #define EXT3_XATTR_INDEX_SECURITY	        6
+ #define EXT3_XATTR_INDEX_NFSD			7
  
  struct ext3_xattr_header {
  	__le32	h_magic;	/* magic number for identification */
***************
*** 63,68 ****
--- 64,70 ----
  extern const struct xattr_handler ext3_xattr_acl_access_handler;
  extern const struct xattr_handler ext3_xattr_acl_default_handler;
  extern const struct xattr_handler ext3_xattr_security_handler;
+ extern const struct xattr_handler ext3_xattr_nfsd_handler;
  
  extern ssize_t ext3_listxattr(struct dentry *, char *, size_t);
  
diff -crN orig/linux-3.5.4/fs/ext3/xattr_nfsd.c linux-3.5.4/fs/ext3/xattr_nfsd.c
*** orig/linux-3.5.4/fs/ext3/xattr_nfsd.c	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/fs/ext3/xattr_nfsd.c	2014-01-20 15:48:09.265333670 -0600
***************
*** 0 ****
--- 1,57 ----
+ /*
+  * linux/fs/ext3/xattr_nfsd.c
+  * Handler for nfsd extended attributes.
+  *
+  * Copyright (C) 2003 by Andreas Gruenbacher, <a.gruenbacher@computer.org>
+  * Copyright (C) 2010 Red Hat, Inc., James Morris <jmorris@redhat.com>
+  */
+ #include <linux/module.h>
+ #include <linux/string.h>
+ #include <linux/capability.h>
+ #include <linux/fs.h>
+ #include "ext3.h"
+ #include "xattr.h"
+ 
+ static size_t ext3_xattr_nfsd_list(struct dentry *dentry, char *list,
+ 				   size_t list_size, const char *name,
+ 				   size_t name_len, int type)
+ {
+ 	const size_t prefix_len = XATTR_NFSD_PREFIX_LEN;
+ 	const size_t total_len = prefix_len + name_len + 1;
+ 
+ 	if (!capable(CAP_SYS_ADMIN))
+ 		return 0;
+ 
+ 	if (list && total_len <= list_size) {
+ 		memcpy(list, XATTR_NFSD_PREFIX, prefix_len);
+ 		memcpy(list+prefix_len, name, name_len);
+ 		list[prefix_len + name_len] = '\0';
+ 	}
+ 	return total_len;
+ }
+ 
+ static int ext3_xattr_nfsd_get(struct dentry *dentry, const char *name,
+ 			       void *buffer, size_t size, int type)
+ {
+ 	if (strcmp(name, "") == 0)
+ 		return -EINVAL;
+ 	return ext3_xattr_get(dentry->d_inode, EXT3_XATTR_INDEX_NFSD,
+ 			      name, buffer, size);
+ }
+ 
+ static int ext3_xattr_nfsd_set(struct dentry *dentry, const char *name,
+ 			       const void *value, size_t size, int flags,
+ 			       int type)
+ {
+ 	if (strcmp(name, "") == 0)
+ 		return -EINVAL;
+ 	return ext3_xattr_set(dentry->d_inode, EXT3_XATTR_INDEX_NFSD, name,
+ 			      value, size, flags);
+ }
+ 
+ const struct xattr_handler ext3_xattr_nfsd_handler = {
+ 	.prefix	= XATTR_NFSD_PREFIX,
+ 	.list	= ext3_xattr_nfsd_list,
+ 	.get	= ext3_xattr_nfsd_get,
+ 	.set	= ext3_xattr_nfsd_set,
+ };
diff -crN orig/linux-3.5.4/fs/file_table.c linux-3.5.4/fs/file_table.c
*** orig/linux-3.5.4/fs/file_table.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/file_table.c	2014-01-20 15:45:10.353335931 -0600
***************
*** 29,34 ****
--- 29,39 ----
  
  #include "internal.h"
  
+ #ifdef CONFIG_SECURITY_DCAC
+ #include "../security/dcac/include/context.h"
+ #include "../security/dcac/include/dcac.h"
+ #endif
+ 
  /* sysctl tunables... */
  struct files_stat_struct files_stat = {
  	.max_files = NR_FILE
***************
*** 223,228 ****
--- 228,241 ----
   */
  static void __fput(struct file *file)
  {
+ #ifdef CONFIG_SECURITY_DCAC
+     if (DCAC_FLAGS_CAN_ADD(file->f_flags)) {
+         if (file->private_data) {
+             kfree(file->private_data);
+         }
+         return;
+     }
+ #endif
  	struct dentry *dentry = file->f_path.dentry;
  	struct vfsmount *mnt = file->f_path.mnt;
  	struct inode *inode = dentry->d_inode;
***************
*** 265,270 ****
--- 278,292 ----
  
  void fput(struct file *file)
  {
+ #ifdef CONFIG_SECURITY_DCAC
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+     if (DCAC_FLAGS_CAN_ADD(file->f_flags)) {
+         if (file->private_data && !ctx->fixed) {
+             dcac_drop_attr(ctx,
+                     (const char *)file->private_data);
+         }
+     }
+ #endif
  	if (atomic_long_dec_and_test(&file->f_count))
  		__fput(file);
  }
diff -crN orig/linux-3.5.4/fs/namei.c linux-3.5.4/fs/namei.c
*** orig/linux-3.5.4/fs/namei.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/namei.c	2014-04-11 12:33:38.606306847 -0500
***************
*** 347,359 ****
--- 347,367 ----
  			return -EACCES;
  	}
  
+ #ifndef CONFIG_SECURITY_DCAC
  	retval = do_inode_permission(inode, mask);
  	if (retval)
  		return retval;
+ #else
+   /*  yxu: still getattr for normal files */
+ 	if (!S_ISDIR(inode->i_mode) || (MAY_READ & mask))
+ 	  do_inode_permission(inode, mask);
+ #endif
  
  	retval = devcgroup_inode_permission(inode, mask);
+ #ifndef CONFIG_SECURITY_DCAC
  	if (retval)
  		return retval;
+ #endif
  
  	return security_inode_permission(inode, mask);
  }
diff -crN orig/linux-3.5.4/fs/nfs/client.c linux-3.5.4/fs/nfs/client.c
*** orig/linux-3.5.4/fs/nfs/client.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfs/client.c	2014-01-20 15:48:09.265333670 -0600
***************
*** 130,135 ****
--- 130,150 ----
  };
  #endif  /* CONFIG_NFS_V3_ACL */
  
+ #ifdef CONFIG_NFS_V3_XATTR
+ static struct rpc_stat		nfs_xattr_rpcstat = { &nfs_xattr_program };
+ static const struct rpc_version *	nfs_xattr_version[] = {
+ 	[3]			= &nfs_xattr_version3,
+ };
+ 
+ struct rpc_program		nfs_xattr_program = {
+ 	.name			= "nfsxattr",
+ 	.number			= NFS_XATTR_PROGRAM,
+ 	.nrvers			= ARRAY_SIZE(nfs_xattr_version),
+ 	.version		= nfs_xattr_version,
+ 	.stats			= &nfs_xattr_rpcstat,
+ };
+ #endif  /* CONFIG_NFS_V3_XATTR */
+ 
  struct nfs_client_initdata {
  	unsigned long init_flags;
  	const char *hostname;
***************
*** 765,770 ****
--- 780,815 ----
  #endif
  
  /*
+  * Initialise an NFSv3 XATTR client connection
+  */
+ #ifdef CONFIG_NFS_V3_XATTR
+ static void nfs_init_server_xattrclient(struct nfs_server *server)
+ {
+ 	if (server->nfs_client->rpc_ops->version != 3)
+ 		goto out_no_xattr;
+ 	if (server->flags & NFS_MOUNT_NOXATTR)
+ 		goto out_no_xattr;
+ 
+ 	server->client_xattr = rpc_bind_new_program(server->client, &nfs_xattr_program, 3);
+ 	if (IS_ERR(server->client_xattr))
+ 		goto out_no_xattr;
+ 
+ 	/* No errors! Assume that XATTR is supported */
+ 	server->caps |= NFS_CAP_XATTR;
+ 	return;
+ 
+ out_no_xattr:
+ 	server->caps &= ~NFS_CAP_XATTR;
+ }
+ #else
+ static inline void nfs_init_server_xattrclient(struct nfs_server *server)
+ {
+ 	server->flags &= ~NFS_MOUNT_NOXATTR;
+ 	server->caps &= ~NFS_CAP_XATTR;
+ }
+ #endif
+ 
+ /*
   * Create a general RPC client
   */
  static int nfs_init_server_rpcclient(struct nfs_server *server,
***************
*** 927,934 ****
  	server->mountd_protocol = data->mount_server.protocol;
  
  	server->namelen  = data->namlen;
! 	/* Create a client RPC handle for the NFSv3 ACL management interface */
  	nfs_init_server_aclclient(server);
  	dprintk("<-- nfs_init_server() = 0 [new %p]\n", clp);
  	return 0;
  
--- 972,983 ----
  	server->mountd_protocol = data->mount_server.protocol;
  
  	server->namelen  = data->namlen;
! 	/*
! 	 * Create client RPC handles for the NFSv3 ACL and XATTR management
! 	 * interfaces
! 	 */
  	nfs_init_server_aclclient(server);
+ 	nfs_init_server_xattrclient(server);
  	dprintk("<-- nfs_init_server() = 0 [new %p]\n", clp);
  	return 0;
  
diff -crN orig/linux-3.5.4/fs/nfs/dir.c linux-3.5.4/fs/nfs/dir.c
*** orig/linux-3.5.4/fs/nfs/dir.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfs/dir.c	2014-04-11 13:10:10.110238231 -0500
***************
*** 40,45 ****
--- 40,48 ----
  #include "iostat.h"
  #include "internal.h"
  #include "fscache.h"
+ #if defined CONFIG_SECURITY_DCAC && defined CONFIG_NFS_V3_XATTR
+ #include "../../security/dcac/include/file.h"
+ #endif
  
  /* #define NFS_DEBUG_VERBOSE 1 */
  
***************
*** 102,111 ****
  	.permission	= nfs_permission,
  	.getattr	= nfs_getattr,
  	.setattr	= nfs_setattr,
! 	.listxattr	= nfs3_listxattr,
! 	.getxattr	= nfs3_getxattr,
! 	.setxattr	= nfs3_setxattr,
! 	.removexattr	= nfs3_removexattr,
  };
  #endif  /* CONFIG_NFS_V3 */
  
--- 105,114 ----
  	.permission	= nfs_permission,
  	.getattr	= nfs_getattr,
  	.setattr	= nfs_setattr,
! 	.listxattr	= generic_listxattr,
! 	.getxattr	= generic_getxattr,
! 	.setxattr	= generic_setxattr,
! 	.removexattr	= generic_removexattr,
  };
  #endif  /* CONFIG_NFS_V3 */
  
***************
*** 2279,2284 ****
--- 2282,2290 ----
  {
  	struct rpc_cred *cred;
  	int res = 0;
+ #if defined CONFIG_SECURITY_DCAC_INODE_CACHE && defined CONFIG_NFS_V3_XATTR
+     dcac_inode_sec_t *isec = inode->i_security;
+ #endif
  
  	if (mask & MAY_NOT_BLOCK)
  		return -ECHILD;
***************
*** 2301,2306 ****
--- 2307,2326 ----
  					&& !(mask & MAY_EXEC))
  				goto out;
  			break;
+ #if defined CONFIG_SECURITY_DCAC_INODE_CACHE && defined CONFIG_NFS_V3_XATTR
+ 		case S_IFDIR:
+       /* yxu: write ops on dir only needed when retry in
+        * security/dcac/lsm.c: dcac_inode_permission.
+        * See also fs/namei.c: inode_permission
+        * We need to fetch fresh attrs */
+ 			if ((mask & MAY_WRITE) && !(mask & MAY_READ)) {
+         struct nfs_fattr *fattr = nfs_alloc_fattr();
+         NFS_PROTO(inode)->getattr(NFS_SERVER(inode), NFS_FH(inode), fattr);
+         nfs_refresh_inode(inode, fattr);
+         nfs_free_fattr(fattr);
+         goto out;
+       }
+ #else
  		case S_IFDIR:
  			/*
  			 * Optimize away all write operations, since the server
***************
*** 2308,2313 ****
--- 2328,2334 ----
  			 */
  			if ((mask & MAY_WRITE) && !(mask & MAY_READ))
  				goto out;
+ #endif
  	}
  
  force_lookup:
***************
*** 2326,2331 ****
--- 2347,2357 ----
  
  	dfprintk(VFS, "NFS: permission(%s/%ld), mask=0x%x, res=%d\n",
  		inode->i_sb->s_id, inode->i_ino, mask, res);
+ #if defined CONFIG_SECURITY_DCAC_INODE_CACHE && defined CONFIG_NFS_V3_XATTR
+     if (!S_ISDIR(inode->i_mode) && !timespec_equal(&isec->ctime, &inode->i_ctime)) {
+         isec->stale = 1;
+     }
+ #endif
  	return res;
  out_notsup:
  	res = nfs_revalidate_inode(NFS_SERVER(inode), inode);
diff -crN orig/linux-3.5.4/fs/nfs/file.c linux-3.5.4/fs/nfs/file.c
*** orig/linux-3.5.4/fs/nfs/file.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfs/file.c	2014-01-20 15:48:09.269333672 -0600
***************
*** 52,61 ****
  	.permission	= nfs_permission,
  	.getattr	= nfs_getattr,
  	.setattr	= nfs_setattr,
! 	.listxattr	= nfs3_listxattr,
! 	.getxattr	= nfs3_getxattr,
! 	.setxattr	= nfs3_setxattr,
! 	.removexattr	= nfs3_removexattr,
  };
  #endif  /* CONFIG_NFS_v3 */
  
--- 52,61 ----
  	.permission	= nfs_permission,
  	.getattr	= nfs_getattr,
  	.setattr	= nfs_setattr,
! 	.listxattr	= generic_listxattr,
! 	.getxattr	= generic_getxattr,
! 	.setxattr	= generic_setxattr,
! 	.removexattr	= generic_removexattr,
  };
  #endif  /* CONFIG_NFS_v3 */
  
diff -crN orig/linux-3.5.4/fs/nfs/internal.h linux-3.5.4/fs/nfs/internal.h
*** orig/linux-3.5.4/fs/nfs/internal.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfs/internal.h	2014-01-20 15:48:09.269333672 -0600
***************
*** 4,9 ****
--- 4,10 ----
  
  #include "nfs4_fs.h"
  #include <linux/mount.h>
+ #include <linux/xattr.h>
  #include <linux/security.h>
  
  #define NFS_MS_MASK (MS_RDONLY|MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_SYNCHRONOUS)
***************
*** 403,408 ****
--- 404,430 ----
  	return nfs_path(&dummy, dentry, buffer, buflen);
  }
  
+ /* nfsxattr.c */
+ extern const struct xattr_handler *nfs3_xattr_handlers[];
+ 
+ extern int nfs3_proc_getxattr(struct inode *inode, const char *namespace,
+ 			      const char *name, void *value, size_t size);
+ extern int nfs3_proc_setxattr(struct inode *inode, const char *namespace,
+ 			      const char *name, const void *value,
+ 			      size_t size, int flags);
+ extern int nfs3_proc_listxattr(struct inode *inode, char *list,
+ 			       size_t list_len);
+ extern int nfs3_init_xattr(struct inode *dir, struct dentry *dentry);
+ 
+ /* nfs3xattr_handers.c */
+ extern struct xattr_handler nfs3_xattr_user_handler;
+ extern struct xattr_handler nfs3_xattr_trusted_handler;
+ extern struct xattr_handler nfs3_xattr_security_handler;
+ 
+ /* nfs3acl.c */
+ extern struct xattr_handler nfs3_xattr_acl_access_handler;
+ extern struct xattr_handler nfs3_xattr_acl_default_handler;
+ 
  /*
   * Determine the actual block size (and log2 thereof)
   */
diff -crN orig/linux-3.5.4/fs/nfs/Kconfig linux-3.5.4/fs/nfs/Kconfig
*** orig/linux-3.5.4/fs/nfs/Kconfig	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfs/Kconfig	2014-01-20 15:48:09.269333672 -0600
***************
*** 49,57 ****
--- 49,61 ----
  
  	  If unsure, say Y.
  
+ config NFS_V3_XATTR_API
+ 	def_bool n
+ 
  config NFS_V3_ACL
  	bool "NFS client support for the NFSv3 ACL protocol extension"
  	depends on NFS_V3
+ 	select NFS_V3_XATTR_API
  	help
  	  Some NFS servers support an auxiliary NFSv3 ACL protocol that
  	  Sun added to Solaris but never became an official part of the
***************
*** 71,76 ****
--- 75,102 ----
  
  	  If unsure, say N.
  
+ config NFS_V3_XATTR
+ 	bool "NFS client support for the NFSv3 XATTR protocol extension (EXPERIMENTAL)"
+ 	depends on NFS_V3 && EXPERIMENTAL
+ 	select NFS_V3_XATTR_API
+ 	help
+ 	  This option selects client suport for the Linux NFSv3 extended
+ 	  attribute protocol extension (XATTR).
+ 
+ 	  This is a side-protocol which extends general support for Linux
+ 	  extended attributes over the network, and is based on the GPLd
+ 	  IRIX implmentation (although not wire-compatible with it).
+ 
+ 	  Only the user.* namespace is currently supported.  When connected
+ 	  to a server which also supports XATTR, the full range of extended
+ 	  attribute system calls:
+ 
+ 	    getxattr(2), listxattr(2), setxattr(2) and removexattr(2)
+ 
+ 	  should work as expected.
+ 
+ 	  If unsure, say N.
+ 
  config NFS_V4
  	bool "NFS client support for NFS version 4"
  	depends on NFS_FS
diff -crN orig/linux-3.5.4/fs/nfs/Makefile linux-3.5.4/fs/nfs/Makefile
*** orig/linux-3.5.4/fs/nfs/Makefile	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfs/Makefile	2014-01-20 15:48:09.269333672 -0600
***************
*** 12,17 ****
--- 12,19 ----
  nfs-$(CONFIG_NFS_V2)	+= proc.o nfs2xdr.o
  nfs-$(CONFIG_NFS_V3)	+= nfs3proc.o nfs3xdr.o
  nfs-$(CONFIG_NFS_V3_ACL)	+= nfs3acl.o
+ nfs-$(CONFIG_NFS_V3_XATTR_API)	+= nfs3xattr.o
+ nfs-$(CONFIG_NFS_V3_XATTR)	+= nfs3xattr_handlers.o
  nfs-$(CONFIG_NFS_V4)	+= nfs4proc.o nfs4xdr.o nfs4state.o nfs4renewd.o \
  			   delegation.o idmap.o \
  			   callback.o callback_xdr.o callback_proc.o \
diff -crN orig/linux-3.5.4/fs/nfs/Module.symvers linux-3.5.4/fs/nfs/Module.symvers
*** orig/linux-3.5.4/fs/nfs/Module.symvers	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/fs/nfs/Module.symvers	2014-01-20 15:48:09.269333672 -0600
***************
*** 0 ****
--- 1,20 ----
+ 0x82cb06c4	nfs_retry_commit	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0x190aa730	nfs_remove_bad_delegation	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0x8981395a	nfs_put_client	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0xd9197481	nfs_commit_free	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0xe79917fb	nfs4_set_ds_client	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0x4a7c75f2	nfs_init_cinfo	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0xaa6ed34f	nfs4_schedule_lease_recovery	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0x5e14f091	nfs_pageio_reset_read_mds	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0x88cfa0db	nfs_commitdata_release	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0xbb9bad3e	nfs_initiate_write	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0x10cd907e	nfs_init_commit	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0x1026038d	nfs_initiate_commit	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0x9ff4ab28	nfs_request_add_commit_list	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0xc4392939	nfs_commitdata_alloc	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0x1ca86a9b	nfs_pageio_reset_write_mds	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0xcea8f2c1	nfs_generic_pg_test	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0x3ca31f35	nfs_net_id	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0x02f4a498	nfs_initiate_read	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0xfa910ea1	nfs4_schedule_stateid_recovery	fs/nfs/nfs	EXPORT_SYMBOL_GPL
+ 0x1dd88ecf	nfs_request_remove_commit_list	fs/nfs/nfs	EXPORT_SYMBOL_GPL
diff -crN orig/linux-3.5.4/fs/nfs/nfs3acl.c linux-3.5.4/fs/nfs/nfs3acl.c
*** orig/linux-3.5.4/fs/nfs/nfs3acl.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfs/nfs3acl.c	2014-01-20 15:48:09.269333672 -0600
***************
*** 10,73 ****
  
  #define NFSDBG_FACILITY	NFSDBG_PROC
  
! ssize_t nfs3_listxattr(struct dentry *dentry, char *buffer, size_t size)
  {
- 	struct inode *inode = dentry->d_inode;
  	struct posix_acl *acl;
! 	int pos=0, len=0;
  
- #	define output(s) do {						\
- 			if (pos + sizeof(s) <= size) {			\
- 				memcpy(buffer + pos, s, sizeof(s));	\
- 				pos += sizeof(s);			\
- 			}						\
- 			len += sizeof(s);				\
- 		} while(0)
- 
- 	acl = nfs3_proc_getacl(inode, ACL_TYPE_ACCESS);
  	if (IS_ERR(acl))
  		return PTR_ERR(acl);
- 	if (acl) {
- 		output("system.posix_acl_access");
- 		posix_acl_release(acl);
- 	}
  
! 	if (S_ISDIR(inode->i_mode)) {
! 		acl = nfs3_proc_getacl(inode, ACL_TYPE_DEFAULT);
! 		if (IS_ERR(acl))
! 			return PTR_ERR(acl);
! 		if (acl) {
! 			output("system.posix_acl_default");
! 			posix_acl_release(acl);
! 		}
! 	}
! 
! #	undef output
  
! 	if (!buffer || len <= size)
! 		return len;
! 	return -ERANGE;
  }
  
! ssize_t nfs3_getxattr(struct dentry *dentry, const char *name,
! 		void *buffer, size_t size)
  {
- 	struct inode *inode = dentry->d_inode;
  	struct posix_acl *acl;
! 	int type, error = 0;
! 
! 	if (strcmp(name, POSIX_ACL_XATTR_ACCESS) == 0)
! 		type = ACL_TYPE_ACCESS;
! 	else if (strcmp(name, POSIX_ACL_XATTR_DEFAULT) == 0)
! 		type = ACL_TYPE_DEFAULT;
! 	else
! 		return -EOPNOTSUPP;
  
! 	acl = nfs3_proc_getacl(inode, type);
  	if (IS_ERR(acl))
  		return PTR_ERR(acl);
  	else if (acl) {
! 		if (type == ACL_TYPE_ACCESS && acl->a_count == 0)
  			error = -ENODATA;
  		else
  			error = posix_acl_to_xattr(acl, buffer, size);
--- 10,50 ----
  
  #define NFSDBG_FACILITY	NFSDBG_PROC
  
! static size_t nfs3_acl_xattr_list(struct dentry *dentry,
! 				  char *list, size_t list_len,
! 				  const char *name, size_t name_len,
! 				  int acl_type)
  {
  	struct posix_acl *acl;
! 	char *acl_name = (acl_type == ACL_TYPE_ACCESS) ?
! 		POSIX_ACL_XATTR_ACCESS : POSIX_ACL_XATTR_DEFAULT;
! 	size_t size = strlen(acl_name) + 1;
! 
! 	acl = nfs3_proc_getacl(dentry->d_inode, acl_type);
! 	if (!acl)
! 		return 0;
  
  	if (IS_ERR(acl))
  		return PTR_ERR(acl);
  
! 	if (list && size <= list_len)
! 		memcpy(list, acl_name, size);
  
! 	posix_acl_release(acl);
! 	return size;
  }
  
! static int nfs3_acl_xattr_get(struct dentry *dentry, const char *name,
! 			      void *buffer, size_t size, int acl_type)
  {
  	struct posix_acl *acl;
! 	int error = 0;
  
! 	acl = nfs3_proc_getacl(dentry->d_inode, acl_type);
  	if (IS_ERR(acl))
  		return PTR_ERR(acl);
  	else if (acl) {
! 		if (acl_type == ACL_TYPE_ACCESS && acl->a_count == 0)
  			error = -ENODATA;
  		else
  			error = posix_acl_to_xattr(acl, buffer, size);
***************
*** 78,120 ****
  	return error;
  }
  
! int nfs3_setxattr(struct dentry *dentry, const char *name,
! 	     const void *value, size_t size, int flags)
  {
- 	struct inode *inode = dentry->d_inode;
  	struct posix_acl *acl;
! 	int type, error;
  
! 	if (strcmp(name, POSIX_ACL_XATTR_ACCESS) == 0)
! 		type = ACL_TYPE_ACCESS;
! 	else if (strcmp(name, POSIX_ACL_XATTR_DEFAULT) == 0)
! 		type = ACL_TYPE_DEFAULT;
! 	else
! 		return -EOPNOTSUPP;
  
! 	acl = posix_acl_from_xattr(value, size);
! 	if (IS_ERR(acl))
! 		return PTR_ERR(acl);
! 	error = nfs3_proc_setacl(inode, type, acl);
  	posix_acl_release(acl);
  
  	return error;
  }
  
! int nfs3_removexattr(struct dentry *dentry, const char *name)
! {
! 	struct inode *inode = dentry->d_inode;
! 	int type;
! 
! 	if (strcmp(name, POSIX_ACL_XATTR_ACCESS) == 0)
! 		type = ACL_TYPE_ACCESS;
! 	else if (strcmp(name, POSIX_ACL_XATTR_DEFAULT) == 0)
! 		type = ACL_TYPE_DEFAULT;
! 	else
! 		return -EOPNOTSUPP;
! 
! 	return nfs3_proc_setacl(inode, type, NULL);
! }
  
  static void __nfs3_forget_cached_acls(struct nfs_inode *nfsi)
  {
--- 55,96 ----
  	return error;
  }
  
! static int nfs3_acl_xattr_set(struct dentry *dentry, const char *name,
! 			      const void *value, size_t size, int flags,
! 			      int acl_type)
  {
  	struct posix_acl *acl;
! 	int error;
  
! 	if (value == NULL && (flags & XATTR_REPLACE))
! 		acl = NULL;	/* remove xattr */
! 	else {
! 		acl = posix_acl_from_xattr(value, size);
! 		if (IS_ERR(acl))
! 			return PTR_ERR(acl);
! 	}
  
! 	error = nfs3_proc_setacl(dentry->d_inode, acl_type, acl);
  	posix_acl_release(acl);
  
  	return error;
  }
  
! struct xattr_handler nfs3_xattr_acl_access_handler = {
! 	.prefix = POSIX_ACL_XATTR_ACCESS,
! 	.flags	= ACL_TYPE_ACCESS,
! 	.list   = nfs3_acl_xattr_list,
! 	.get    = nfs3_acl_xattr_get,
! 	.set    = nfs3_acl_xattr_set,
! };
! 
! struct xattr_handler nfs3_xattr_acl_default_handler = {
! 	.prefix = POSIX_ACL_XATTR_DEFAULT,
! 	.flags	= ACL_TYPE_DEFAULT,
! 	.list   = nfs3_acl_xattr_list,
! 	.get    = nfs3_acl_xattr_get,
! 	.set    = nfs3_acl_xattr_set,
! };
  
  static void __nfs3_forget_cached_acls(struct nfs_inode *nfsi)
  {
diff -crN orig/linux-3.5.4/fs/nfs/nfs3proc.c linux-3.5.4/fs/nfs/nfs3proc.c
*** orig/linux-3.5.4/fs/nfs/nfs3proc.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfs/nfs3proc.c	2014-04-20 17:40:25.871355611 -0500
***************
*** 22,27 ****
--- 22,31 ----
  #include "iostat.h"
  #include "internal.h"
  
+ #ifdef CONFIG_SECURITY_DCAC
+ #include "nfs_dcac.h"
+ #endif
+ 
  #define NFSDBG_FACILITY		NFSDBG_PROC
  
  /* A wrapper to handle the EJUKEBOX and EKEYEXPIRED error messages */
***************
*** 331,336 ****
--- 335,343 ----
  	data->arg.create.name = dentry->d_name.name;
  	data->arg.create.len = dentry->d_name.len;
  	data->arg.create.sattr = sattr;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_set_hash(dir, &data->arg.create.hash, &data->arg.create.by_acl);
+ #endif
  
  	data->arg.create.createmode = NFS3_CREATE_UNCHECKED;
  	if (flags & O_EXCL) {
***************
*** 344,349 ****
--- 351,363 ----
  	for (;;) {
  		status = nfs3_do_create(dir, dentry, data);
  
+ #ifdef CONFIG_SECURITY_DCAC
+     if (status) {
+       dcac_inode_sec_t *isec = dir->i_security;
+       isec->stale = 1;
+     }
+ #endif
+ 
  		if (status != -ENOTSUPP)
  			break;
  		/* If the server doesn't support the exclusive creation
***************
*** 387,392 ****
--- 401,409 ----
  			goto out;
  	}
  	status = nfs3_proc_set_default_acl(dir, dentry->d_inode, mode);
+ 	if (status != 0)
+ 		goto out;
+ 	status = nfs3_init_xattr(dir, dentry);
  out:
  	nfs3_free_createdata(data);
  	dprintk("NFS reply create: %d\n", status);
***************
*** 400,405 ****
--- 417,423 ----
  		.fh = NFS_FH(dir),
  		.name = *name,
  	};
+ 
  	struct nfs_removeres res;
  	struct rpc_message msg = {
  		.rpc_proc = &nfs3_procedures[NFS3PROC_REMOVE],
***************
*** 407,412 ****
--- 425,433 ----
  		.rpc_resp = &res,
  	};
  	int status = -ENOMEM;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_set_hash(dir, &arg.hash, &arg.by_acl);
+ #endif
  
  	dprintk("NFS call  remove %s\n", name->name);
  	res.dir_attr = nfs_alloc_fattr();
***************
*** 414,419 ****
--- 435,446 ----
  		goto out;
  
  	status = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);
+ #ifdef CONFIG_SECURITY_DCAC
+   if (status) {
+     dcac_inode_sec_t *isec = dir->i_security;
+     isec->stale = 1;
+   }
+ #endif
  	nfs_post_op_update_inode(dir, res.dir_attr);
  	nfs_free_fattr(res.dir_attr);
  out:
***************
*** 486,491 ****
--- 513,524 ----
  		.rpc_resp	= &res,
  	};
  	int status = -ENOMEM;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_inode_sec_t *old_isec;
+   dcac_inode_sec_t *new_isec;
+   dcac_nfs_set_hash(old_dir, &arg.old_hash, &arg.old_by_acl);
+   dcac_nfs_set_hash(new_dir, &arg.new_hash, &arg.new_by_acl);
+ #endif
  
  	dprintk("NFS call  rename %s -> %s\n", old_name->name, new_name->name);
  
***************
*** 495,500 ****
--- 528,541 ----
  		goto out;
  
  	status = rpc_call_sync(NFS_CLIENT(old_dir), &msg, 0);
+ #ifdef CONFIG_SECURITY_DCAC
+   if (status) {
+     old_isec = old_dir->i_security;
+     old_isec->stale = 1;
+     new_isec = new_dir->i_security;
+     new_isec->stale = 1;
+   }
+ #endif
  	nfs_post_op_update_inode(old_dir, res.old_fattr);
  	nfs_post_op_update_inode(new_dir, res.new_fattr);
  out:
***************
*** 513,518 ****
--- 554,560 ----
  		.toname		= name->name,
  		.tolen		= name->len
  	};
+ 
  	struct nfs3_linkres	res;
  	struct rpc_message msg = {
  		.rpc_proc	= &nfs3_procedures[NFS3PROC_LINK],
***************
*** 520,525 ****
--- 562,570 ----
  		.rpc_resp	= &res,
  	};
  	int status = -ENOMEM;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_set_hash(dir, &arg.hash, &arg.by_acl);
+ #endif
  
  	dprintk("NFS call  link %s\n", name->name);
  	res.fattr = nfs_alloc_fattr();
***************
*** 528,533 ****
--- 573,584 ----
  		goto out;
  
  	status = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);
+ #ifdef CONFIG_SECURITY_DCAC
+   if (status) {
+     dcac_inode_sec_t *isec = dir->i_security;
+     isec->stale = 1;
+   }
+ #endif
  	nfs_post_op_update_inode(dir, res.dir_attr);
  	nfs_post_op_update_inode(inode, res.fattr);
  out:
***************
*** 559,566 ****
--- 610,626 ----
  	data->arg.symlink.pages = &page;
  	data->arg.symlink.pathlen = len;
  	data->arg.symlink.sattr = sattr;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_set_hash(dir, &data->arg.symlink.hash, &data->arg.symlink.by_acl);
+ #endif
  
  	status = nfs3_do_create(dir, dentry, data);
+ #ifdef CONFIG_SECURITY_DCAC
+     if (status) {
+       dcac_inode_sec_t *isec = dir->i_security;
+       isec->stale = 1;
+     }
+ #endif
  
  	nfs3_free_createdata(data);
  out:
***************
*** 588,599 ****
--- 648,674 ----
  	data->arg.mkdir.name = dentry->d_name.name;
  	data->arg.mkdir.len = dentry->d_name.len;
  	data->arg.mkdir.sattr = sattr;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_set_hash(dir, &data->arg.mkdir.hash, &data->arg.mkdir.by_acl);
+ #endif
  
  	status = nfs3_do_create(dir, dentry, data);
+ 
+ #ifdef CONFIG_SECURITY_DCAC
+     if (status) {
+       dcac_inode_sec_t *isec = dir->i_security;
+       isec->stale = 1;
+     }
+ #endif
+ 
  	if (status != 0)
  		goto out;
  
  	status = nfs3_proc_set_default_acl(dir, dentry->d_inode, mode);
+ 
+ 	if (status != 0)
+ 		goto out;
+ 	status = nfs3_init_xattr(dir, dentry);
  out:
  	nfs3_free_createdata(data);
  	dprintk("NFS reply mkdir: %d\n", status);
***************
*** 609,619 ****
--- 684,698 ----
  		.name		= name->name,
  		.len		= name->len
  	};
+ 
  	struct rpc_message msg = {
  		.rpc_proc	= &nfs3_procedures[NFS3PROC_RMDIR],
  		.rpc_argp	= &arg,
  	};
  	int status = -ENOMEM;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_set_hash(dir, &arg.hash, &arg.by_acl);
+ #endif
  
  	dprintk("NFS call  rmdir %s\n", name->name);
  	dir_attr = nfs_alloc_fattr();
***************
*** 622,627 ****
--- 701,712 ----
  
  	msg.rpc_resp = dir_attr;
  	status = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);
+ #ifdef CONFIG_SECURITY_DCAC
+   if (status) {
+     dcac_inode_sec_t *isec = dir->i_security;
+     isec->stale = 1;
+   }
+ #endif
  	nfs_post_op_update_inode(dir, dir_attr);
  	nfs_free_fattr(dir_attr);
  out:
***************
*** 727,737 ****
--- 812,835 ----
  		status = -EINVAL;
  		goto out;
  	}
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_set_hash(dir, &data->arg.mknod.hash, &data->arg.mknod.by_acl);
+ #endif
  
  	status = nfs3_do_create(dir, dentry, data);
+ #ifdef CONFIG_SECURITY_DCAC
+     if (status) {
+       dcac_inode_sec_t *isec = dir->i_security;
+       isec->stale = 1;
+     }
+ #endif
+ 
  	if (status != 0)
  		goto out;
  	status = nfs3_proc_set_default_acl(dir, dentry->d_inode, mode);
+ 	if (status != 0)
+ 		goto out;
+ 	status = nfs3_init_xattr(dir, dentry);
  out:
  	nfs3_free_createdata(data);
  	dprintk("NFS reply mknod: %d\n", status);
diff -crN orig/linux-3.5.4/fs/nfs/nfs3xattr.c linux-3.5.4/fs/nfs/nfs3xattr.c
*** orig/linux-3.5.4/fs/nfs/nfs3xattr.c	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/fs/nfs/nfs3xattr.c	2014-01-24 18:27:14.297470644 -0600
***************
*** 0 ****
--- 1,335 ----
+ /*
+  * Extended attribute (xattr) API and protocol for NFSv3.
+  *
+  * Based on the ACL code.
+  *
+  * Copyright (C) 2009 Red Hat, Inc., James Morris <jmorris@redhat.com>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2,
+  * as published by the Free Software Foundation.
+  */
+ #include <linux/fs.h>
+ #include <linux/nfs.h>
+ #include <linux/nfs3.h>
+ #include <linux/nfs_fs.h>
+ #include <linux/xattr.h>
+ 
+ #include "internal.h"
+ 
+ #define NFSDBG_FACILITY	NFSDBG_PROC
+ 
+ #if defined CONFIG_SECURITY_DCAC_INODE_CACHE
+ #include "../../security/dcac/include/file.h"
+ #include <linux/time.h>
+ #endif
+ 
+ const struct xattr_handler *nfs3_xattr_handlers[] = {
+ #ifdef CONFIG_NFS_V3_XATTR
+ 	&nfs3_xattr_user_handler,
+ 	&nfs3_xattr_trusted_handler,
+ 	&nfs3_xattr_security_handler,
+ #endif
+ #ifdef CONFIG_NFS_V3_ACL
+ 	&nfs3_xattr_acl_access_handler,
+ 	&nfs3_xattr_acl_default_handler,
+ #endif
+ 	NULL
+ };
+ 
+ #ifdef CONFIG_NFS_V3_XATTR
+ /*
+  * XATTR protocol
+  */
+ 
+ /*
+  * Call GETXATTR
+  *
+  * FIXME:
+  * - Cache xattrs
+  * - Handle size probing
+  */
+ int nfs3_proc_getxattr(struct inode *inode, const char *namespace,
+ 		       const char *name, void *value, size_t size)
+ {
+ 	int status;
+ 	struct nfs_fattr fattr;
+ 	struct nfs_server *server = NFS_SERVER(inode);
+ 	struct nfs3_getxattrargs args = {
+ 		.fh		= NFS_FH(inode),
+ 	};
+ 	struct nfs3_getxattrres res = {
+ 		.fattr		= &fattr,
+ 	};
+ 	struct rpc_message msg = {
+ 		.rpc_argp	= &args,
+ 		.rpc_resp	= &res,
+ 	};
+ 
+     // yxu
+     if (strcmp(name, "capability") == 0 ||
+        strcmp(name, "selinux") == 0 )
+         return -ENODATA;
+ 
+ 	if (!name || !*name)
+ 		return -EINVAL;
+ 
+ 	if (size > XATTR_SIZE_MAX)
+ 		return -EINVAL;
+ 
+ 	if (!nfs_server_capable(inode, NFS_CAP_XATTR))
+ 		return -EOPNOTSUPP;
+ 
+ 	status = nfs_revalidate_inode(server, inode);
+ 	if (status < 0)
+ 		return status;
+ 
+     //yxu
+ #if 0 
+ 	/*
+ 	 * Applications usually first probe the xattr value size, then
+ 	 * perform a full call.  For now, just return a dummy value.
+ 	 */
+ 	if (!size || !value)
+ 		return 4096;
+ #endif
+ 
+ 	args.xattr_namespace = namespace;
+ 	args.xattr_name = name;
+ 	args.xattr_size_max = size;
+ 
+ 	/*
+ 	 * FIXME
+ 	 *
+ 	 * This is ugly.  We pre-allocate a buffer for the XDR layer to use,
+ 	 * passing the size of the buffer via xattr_val_len, which is
+ 	 * updated with the actual length decoded.  We should investigate
+ 	 * using the page-based interface used by ACLs and others, or some
+ 	 * other better way.
+ 	 */
+ 	res.xattr_val_len = size;
+ 	res.xattr_val = kmalloc(size, GFP_KERNEL);
+ 	if (!res.xattr_val)
+ 		return -ENOMEM;
+ 
+ 	dprintk("NFS call getxattr %s%s %zd\n", namespace, name, size);
+ 
+ 	msg.rpc_proc = &server->client_xattr->cl_procinfo[XATTRPROC3_GETXATTR];
+ 	nfs_fattr_init(&fattr);
+ 	status = rpc_call_sync(server->client_xattr, &msg, 0);
+ 
+ 	dprintk("NFS reply getxattr: status=%d len=%d\n",
+ 		status, res.xattr_val_len);
+ 
+ 	switch (status) {
+ 	case 0:
+ 		status = nfs_refresh_inode(inode, &fattr);
+ 		break;
+ 	case -EPFNOSUPPORT:
+ 	case -EPROTONOSUPPORT:
+ 		dprintk("NFS_V3_XATTR extension not supported; disabling\n");
+ 		server->caps &= ~NFS_CAP_XATTR;
+ 	case -ENOTSUPP:
+ 		status = -EOPNOTSUPP;
+ 	default:
+ 		goto cleanup;
+ 	}
+ 
+ 	status = res.xattr_val_len;
+ 
+     //yxu mod
+ 	if (status <= size && value)
+ 		memcpy(value, res.xattr_val, status);
+ 
+ cleanup:
+ 	kfree(res.xattr_val);
+ 	return status;
+ }
+ 
+ /*
+  * Call SETXATTR or RMXATTR
+  *
+  * RMXATTR is invoked with a NULL buffer and XATTR_REPLACE.
+  *
+  */
+ int nfs3_proc_setxattr(struct inode *inode, const char *namespace,
+ 		       const char *name, const void *value,
+ 		       size_t size, int flags)
+ 
+ {
+ 	int status;
+ 	struct nfs_fattr fattr;
+ 	struct nfs_server *server = NFS_SERVER(inode);
+ 	struct nfs3_setxattrargs args = {
+ 		.fh		= NFS_FH(inode),
+ 	};
+ 	struct nfs3_setxattrres res = {
+ 		.fattr		= &fattr,
+ 	};
+ 	struct rpc_message msg = {
+ 		.rpc_argp	= &args,
+ 		.rpc_resp	= &res,
+ 	};
+ 
+ 	if (!name || !*name)
+ 		return -EINVAL;
+ 
+ 	if (!nfs_server_capable(inode, NFS_CAP_XATTR))
+ 		return -EOPNOTSUPP;
+ 
+ 	status = nfs_revalidate_inode(server, inode);
+ 	if (status < 0)
+ 		return status;
+ 
+ 	args.xattr_namespace = namespace;
+ 	args.xattr_name = name;
+ 	args.xattr_flags = flags;
+ 	args.xattr_val = value;
+ 	args.xattr_val_len = size;
+ 
+ 	dprintk("NFS call setxattr %s%s %zd 0x%08x\n",
+ 		namespace, name, size, flags);
+ 
+ 	msg.rpc_proc = &server->client_xattr->cl_procinfo[XATTRPROC3_SETXATTR];
+ 	nfs_fattr_init(&fattr);
+ 	status = rpc_call_sync(server->client_xattr, &msg, 0);
+ 
+ 	dprintk("NFS reply setxattr: status=%d\n", status);
+ 
+ 	switch (status) {
+ 	case 0:
+ 		status = nfs_refresh_inode(inode, &fattr);
+ 		break;
+ 	case -EPFNOSUPPORT:
+ 	case -EPROTONOSUPPORT:
+ 		dprintk("NFS_V3_XATTR extension not supported; disabling\n");
+ 		server->caps &= ~NFS_CAP_XATTR;
+ 	case -ENOTSUPP:
+ 		status = -EOPNOTSUPP;
+ 	default:
+ 		break;
+ 	}
+ 	return status;
+ }
+ 
+ /*
+  * Call LISTXATTR
+  */
+ int nfs3_proc_listxattr(struct inode *inode, char *list, size_t list_len)
+ {
+ 	int status;
+ 	struct nfs_fattr fattr;
+ 	struct nfs_server *server = NFS_SERVER(inode);
+ 	struct nfs3_listxattrargs args = {
+ 		.fh		= NFS_FH(inode),
+ 	};
+ 	struct nfs3_listxattrres res = {
+ 		.fattr		= &fattr,
+ 	};
+ 	struct rpc_message msg = {
+ 		.rpc_argp	= &args,
+ 		.rpc_resp	= &res,
+ 	};
+ 
+ 	if (list_len > XATTR_LIST_MAX)
+ 		return -EINVAL;
+ 
+ 	if (!nfs_server_capable(inode, NFS_CAP_XATTR))
+ 		return -EOPNOTSUPP;
+ 
+ 	dprintk("NFS call listxattr %zd\n", list_len);
+ 
+ 	/* FIXME: handle probes */
+ 	if (!list || !list_len)
+ 		return 1024;
+ 
+ 	args.xattr_list_max = list_len;
+ 
+ 	/* FIXME (see comments for getxattr) */
+ 	res.xattr_list_len = list_len;
+ 	res.xattr_list = kmalloc(list_len, GFP_KERNEL);
+ 	if (!res.xattr_list)
+ 		return -ENOMEM;
+ 
+ 	msg.rpc_proc = &server->client_xattr->cl_procinfo[XATTRPROC3_LISTXATTR];
+ 	nfs_fattr_init(&fattr);
+ 	status = rpc_call_sync(server->client_xattr, &msg, 0);
+ 
+ 	dprintk("NFS reply listxattr: status=%d\n", status);
+ 
+ 	switch (status) {
+ 	case 0:
+ 		status = nfs_refresh_inode(inode, &fattr);
+ 		break;
+     case -ENODATA:
+         status = 0;
+         goto cleanup;
+ 	case -EPFNOSUPPORT:
+ 	case -EPROTONOSUPPORT:
+ 		dprintk("NFS_V3_XATTR extension not supported; disabling\n");
+ 		server->caps &= ~NFS_CAP_XATTR;
+ 	case -ENOTSUPP:
+ 		status = -EOPNOTSUPP;
+ 	default:
+ 		goto cleanup;
+ 	}
+ 
+ 	status = res.xattr_list_len;
+ 	if (status <= list_len)
+ 		memcpy(list, res.xattr_list, status);
+ 
+ cleanup:
+ 	kfree(res.xattr_list);
+ 	return status;
+ }
+ 
+ 
+ //yxu
+ static int nfs3_initxattrs (struct inode *inode,
+         const struct xattr *xattr_array, void *fs_data)
+ {
+ #if 0
+     const struct xattr *xattr;
+     struct dentry *dentry = (struct dentry *)fs_data;
+     int err = 0;
+ 
+     for (xattr = xattr_array; xattr->name != NULL; xattr++) {
+         err = security_inode_setsecctx(dentry,
+                 xattr->value, xattr->value_len);
+         if (err < 0)
+             break;
+         //yxu: only set the first xattr, which is defined by lsm.
+         //Not support evm.
+         break;
+     }
+     return err;
+ #endif
+   return 0;
+ }
+ 
+ /*
+  * Create an xattr for a newly created file, if required by the security
+  * subsystem.
+  */
+ int nfs3_init_xattr(struct inode *dir, struct dentry *dentry)
+ {
+ 	int ret;
+ 	struct inode *inode = dentry->d_inode;
+ #if defined CONFIG_SECURITY_DCAC_INODE_CACHE
+   dcac_inode_sec_t *isec = inode->i_security;
+ #endif
+ 
+   // yxu: pass the dentry to nfs3_initxattrs, as fs_data
+   ret = security_inode_init_security(inode, dir, NULL, nfs3_initxattrs, dentry);
+ #if defined CONFIG_SECURITY_DCAC_INODE_CACHE
+   memcpy(&isec->ctime, &inode->i_ctime, sizeof(isec->ctime));
+ #endif
+ 	if (ret) {
+ 		if (ret == -EOPNOTSUPP)
+ 			return 0;
+ 		return ret;
+ 	}
+ 
+ 	return ret;
+ }
+ #endif	/* CONFIG_NFS_V3_XATTR */
diff -crN orig/linux-3.5.4/fs/nfs/nfs3xattr_handlers.c linux-3.5.4/fs/nfs/nfs3xattr_handlers.c
*** orig/linux-3.5.4/fs/nfs/nfs3xattr_handlers.c	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/fs/nfs/nfs3xattr_handlers.c	2014-01-20 15:48:09.269333672 -0600
***************
*** 0 ****
--- 1,121 ----
+ /*
+  * Client support for the NFS_XATTR protocol.
+  *
+  * Copyright (C) 2009 Red Hat, Inc., James Morris <jmorris@redhat.com>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2,
+  * as published by the Free Software Foundation.
+  */
+ #include <linux/fs.h>
+ #include <linux/nfs.h>
+ #include <linux/nfs3.h>
+ #include <linux/nfs_fs.h>
+ 
+ #include "internal.h"
+ 
+ #define NFSDBG_FACILITY	NFSDBG_PROC
+ 
+ /*
+  * 'user' namespace
+  */
+ 
+ /*
+  * Call the LISTXATTR procedure only once per syscall, when the user
+  * handler is invoked.
+  */
+ static size_t nfs3_user_xattr_list(struct dentry *dentry, char *list,
+ 				   size_t list_len, const char *name,
+ 				   size_t name_len, int hflags)
+ {
+ 
+ 	return nfs3_proc_listxattr(dentry->d_inode, list, list_len);
+ }
+ 
+ static size_t nfs3_noop_xattr_list(struct dentry *dentry, char *list,
+ 				   size_t list_len, const char *name,
+ 				   size_t name_len, int hflags)
+ {
+ 	return 0;
+ }
+ 
+ static int nfs3_user_xattr_get(struct dentry *dentry, const char *name,
+ 			       void *buffer, size_t size, int hflags)
+ {
+ 	return nfs3_proc_getxattr(dentry->d_inode, XATTR_USER_PREFIX,
+ 				  name, buffer, size);
+ }
+ 
+ static int nfs3_user_xattr_set(struct dentry *dentry, const char *name,
+ 			       const void *value, size_t size,
+ 			       int flags, int hflags)
+ {
+ 	return nfs3_proc_setxattr(dentry->d_inode, XATTR_USER_PREFIX,
+ 				  name, value, size, flags);
+ }
+ 
+ /*
+  * 'trusted' namespace
+  */
+ struct xattr_handler nfs3_xattr_user_handler = {
+ 	.prefix = XATTR_USER_PREFIX,
+ 	.list	= nfs3_user_xattr_list,
+ 	.get    = nfs3_user_xattr_get,
+ 	.set    = nfs3_user_xattr_set,
+ };
+ 
+ static int nfs3_trusted_xattr_get(struct dentry *dentry, const char *name,
+ 				  void *buffer, size_t size, int hflags)
+ {
+ 	return nfs3_proc_getxattr(dentry->d_inode, XATTR_TRUSTED_PREFIX,
+ 				  name, buffer, size);
+ }
+ 
+ static int nfs3_trusted_xattr_set(struct dentry *dentry, const char *name,
+ 				  const void *value, size_t size,
+ 				  int flags, int hflags)
+ {
+ 	return nfs3_proc_setxattr(dentry->d_inode, XATTR_TRUSTED_PREFIX,
+ 				  name, value, size, flags);
+ }
+ 
+ struct xattr_handler nfs3_xattr_trusted_handler = {
+ 	.prefix = XATTR_TRUSTED_PREFIX,
+ 	.list	= nfs3_noop_xattr_list,
+ 	.get    = nfs3_trusted_xattr_get,
+ 	.set    = nfs3_trusted_xattr_set,
+ };
+ 
+ /*
+  * 'security' namespace
+  */
+ static int nfs3_security_xattr_get(struct dentry *dentry, const char *name,
+ 				   void *buffer, size_t size, int hflags)
+ {
+ 	return nfs3_proc_getxattr(dentry->d_inode, XATTR_SECURITY_PREFIX,
+ 				  name, buffer, size);
+ }
+ 
+ static int nfs3_security_xattr_set(struct dentry *dentry, const char *name,
+ 				   const void *value, size_t size,
+ 				   int flags, int hflags)
+ {
+ 	int ret;
+ 
+ 	ret = nfs3_proc_setxattr(dentry->d_inode, XATTR_SECURITY_PREFIX,
+ 				  name, value, size, flags);
+ 
+ 	/* FIXME: once size probing is fixed, don't translate to zero */
+ 	if ((flags & XATTR_REPLACE) && ret == -ENODATA) {
+ 		printk(KERN_DEBUG "%s: ignoring -ENODATA (fixme)\n", __func__);
+ 		ret = 0;
+ 	}
+ 	return ret;
+ }
+ 
+ struct xattr_handler nfs3_xattr_security_handler = {
+ 	.prefix = XATTR_SECURITY_PREFIX,
+ 	.list	= nfs3_noop_xattr_list,
+ 	.get    = nfs3_security_xattr_get,
+ 	.set    = nfs3_security_xattr_set,
+ };
diff -crN orig/linux-3.5.4/fs/nfs/nfs3xdr.c linux-3.5.4/fs/nfs/nfs3xdr.c
*** orig/linux-3.5.4/fs/nfs/nfs3xdr.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfs/nfs3xdr.c	2014-04-11 01:33:38.931546696 -0500
***************
*** 22,27 ****
--- 22,31 ----
  #include <linux/nfsacl.h>
  #include "internal.h"
  
+ #ifdef CONFIG_SECURITY_DCAC
+ #include "nfs_dcac.h"
+ #endif
+ 
  #define NFSDBG_FACILITY		NFSDBG_XDR
  
  /* Mapping from NFS error code to "errno" error code. */
***************
*** 89,94 ****
--- 93,118 ----
  static int nfs3_stat_to_errno(enum nfs_stat);
  
  /*
+  * FIXME: currently, the RPC layer will allocate the maximum buffer size
+  * here for each call (which can be ~ 64k).  The Labeled NFS prototype code
+  * uses 4k, although we should not impose limits for NFS which don't exist
+  * in the OS unless absolutely necsssary.  We likely need a dynamic scheme
+  * here, possibly using pages.
+  */
+ #define XATTR3_xattrname_sz	(1+(XATTR_NAME_MAX>>2))
+ #define XATTR3_xattrval_sz	(1+(XATTR_SIZE_MAX>>2))
+ #define XATTR3_xattrlist_sz	(1+(XATTR_LIST_MAX>>2))
+ 
+ #define XATTR3_getxattrargs_sz	(NFS3_fh_sz+XATTR3_xattrname_sz+1)
+ #define XATTR3_getxattrres_sz	(1+NFS3_post_op_attr_sz+XATTR3_xattrval_sz)
+ 
+ #define XATTR3_setxattrargs_sz	(NFS3_fh_sz+XATTR3_xattrname_sz+XATTR3_xattrval_sz+1)
+ #define XATTR3_setxattrres_sz	(1+NFS3_post_op_attr_sz)
+ 
+ #define XATTR3_listxattrargs_sz	(NFS3_fh_sz+1)
+ #define XATTR3_listxattrres_sz	(1+NFS3_post_op_attr_sz+XATTR3_xattrlist_sz)
+ 
+ /*
   * Map file type to S_IFMT bits
   */
  static const umode_t nfs_type2fmt[] = {
***************
*** 743,748 ****
--- 767,877 ----
  	return -EIO;
  }
  
+ #ifdef CONFIG_NFS_V3_XATTR
+ /*
+  * Special case of xdr_encode_opaque, where the xattr helpers hand us
+  * separate namespace and name buffers, which we encode as a single XDR
+  * string over the wire.  Neither namespace nor name may be empty or null.
+  */
+ // yxu: modified for 3.5.4
+ static void xattr_encode_name(struct xdr_stream *xdr,
+         const char *namespace, const char *name)
+ {
+ 	unsigned int nslen, namelen, totlen, quadlen, padding;
+     __be32 *p;
+ 
+ 	nslen = strlen(namespace);
+ 	namelen = strlen(name);
+ 	totlen = nslen + namelen;
+ 	quadlen = XDR_QUADLEN(totlen);
+ 	padding = (quadlen << 2) - totlen;
+ 
+     p = xdr_reserve_space(xdr, totlen + 4); // 4 bytes for 'totlen'
+ 	*p++ = cpu_to_be32(totlen);
+ 	memcpy(p, namespace, nslen);
+ 	memcpy((char *)p + nslen, name, namelen);
+ 
+ 	if (padding != 0)
+ 		memset((char *)p + totlen, 0, padding);
+ }
+ 
+ /*
+  * Encode GETXATTR arguments
+  */
+ // yxu: modified for 3.5.4
+ static void nfs3_xdr_getxattrargs(struct rpc_rqst *req,
+         struct xdr_stream *xdr,
+         struct nfs3_getxattrargs *args)
+ {
+     /*
+ 	p = xdr_encode_fhandle(p, args->fh);
+ 	p = xattr_encode_name(p, args->xattr_namespace, args->xattr_name);
+ 	*p++ = htonl(args->xattr_size_max);
+ 	req->rq_slen = xdr_adjust_iovec(req->rq_svec, p);
+ 	return 0;
+     */
+ 
+ 	encode_nfs_fh3(xdr, args->fh);
+ 	xattr_encode_name(xdr, args->xattr_namespace, args->xattr_name);
+ 	encode_uint32(xdr, args->xattr_size_max);
+ 
+ 
+ 	//return 0;
+ }
+ 
+ /*
+  * Encode SETXATTR arguments
+  */
+ static void nfs3_xdr_setxattrargs(struct rpc_rqst *req,
+         struct xdr_stream *xdr,
+         struct nfs3_setxattrargs *args)
+ {
+     /*
+ 	p = xdr_encode_fhandle(p, args->fh);
+ 	p = xattr_encode_name(p, args->xattr_namespace, args->xattr_name);
+ 	p = xdr_encode_array(p, args->xattr_val, args->xattr_val_len);
+ 	*p++ = htonl(args->xattr_flags);
+ 	req->rq_slen = xdr_adjust_iovec(req->rq_svec, p);
+ 	return 0;
+     */
+ 
+     __be32 *p;
+     int quadlen, padlen;
+     encode_nfs_fh3(xdr, args->fh);
+     xattr_encode_name(xdr, args->xattr_namespace, args->xattr_name);
+     quadlen = (args->xattr_val_len + 3) >> 2;
+     padlen = (quadlen << 2) - args->xattr_val_len;
+     p = xdr_reserve_space(xdr, (quadlen << 2) + 4);
+     *p++ = cpu_to_be32(args->xattr_val_len);
+     memcpy(p, args->xattr_val, args->xattr_val_len);
+     if (padlen > 0 )
+         memset((void *)p + args->xattr_val_len, 0, padlen);
+     encode_uint32(xdr, args->xattr_flags);
+ 
+     //return 0;
+ }
+ 
+ /*
+  * Encode LISTXATTR arguments
+  */
+ static void nfs3_xdr_listxattrargs(struct rpc_rqst *req,
+         struct xdr_stream *xdr,
+         struct nfs3_listxattrargs *args)
+ {
+     /*
+ 	p = xdr_encode_fhandle(p, args->fh);
+ 	*p++ = htonl(args->xattr_list_max);
+ 	req->rq_slen = xdr_adjust_iovec(req->rq_svec, p);
+ 	return 0;
+     */
+     encode_nfs_fh3(xdr, args->fh);
+     encode_uint32(xdr, args->xattr_list_max);
+ 
+     //return 0;
+ }
+ #endif	/* CONFIG_NFS_V3_XATTR */
+ 
+ 
  /*
   * pre_op_attr
   *	union pre_op_attr switch (bool attributes_follow) {
***************
*** 899,904 ****
--- 1028,1036 ----
  				     const struct nfs3_diropargs *args)
  {
  	encode_diropargs3(xdr, args->fh, args->name, args->len);
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_encode_hash(xdr, &args->hash, args->by_acl);
+ #endif
  }
  
  /*
***************
*** 1054,1059 ****
--- 1186,1195 ----
  				     const struct nfs3_createargs *args)
  {
  	encode_diropargs3(xdr, args->fh, args->name, args->len);
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_encode_hash(xdr, &args->hash, args->by_acl);
+   dcac_nfs_encode_def_acl(xdr);
+ #endif
  	encode_createhow3(xdr, args);
  }
  
***************
*** 1070,1075 ****
--- 1206,1215 ----
  				    const struct nfs3_mkdirargs *args)
  {
  	encode_diropargs3(xdr, args->fh, args->name, args->len);
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_encode_hash(xdr, &args->hash, args->by_acl);
+   dcac_nfs_encode_def_acl(xdr);
+ #endif
  	encode_sattr3(xdr, args->sattr);
  }
  
***************
*** 1098,1103 ****
--- 1238,1247 ----
  				      const struct nfs3_symlinkargs *args)
  {
  	encode_diropargs3(xdr, args->fromfh, args->fromname, args->fromlen);
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_encode_hash(xdr, &args->hash, args->by_acl);
+   dcac_nfs_encode_def_acl(xdr);
+ #endif
  	encode_symlinkdata3(xdr, args);
  }
  
***************
*** 1158,1163 ****
--- 1302,1311 ----
  				    const struct nfs3_mknodargs *args)
  {
  	encode_diropargs3(xdr, args->fh, args->name, args->len);
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_encode_hash(xdr, &args->hash, args->by_acl);
+   dcac_nfs_encode_def_acl(xdr);
+ #endif
  	encode_mknoddata3(xdr, args);
  }
  
***************
*** 1173,1178 ****
--- 1321,1329 ----
  				     const struct nfs_removeargs *args)
  {
  	encode_diropargs3(xdr, args->fh, args->name.name, args->name.len);
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_encode_hash(xdr, &args->hash, args->by_acl);
+ #endif
  }
  
  /*
***************
*** 1192,1197 ****
--- 1343,1352 ----
  
  	encode_diropargs3(xdr, args->old_dir, old->name, old->len);
  	encode_diropargs3(xdr, args->new_dir, new->name, new->len);
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_encode_hash(xdr, &args->old_hash, args->old_by_acl);
+   dcac_nfs_encode_hash(xdr, &args->new_hash, args->new_by_acl);
+ #endif
  }
  
  /*
***************
*** 1208,1213 ****
--- 1363,1371 ----
  {
  	encode_nfs_fh3(xdr, args->fromfh);
  	encode_diropargs3(xdr, args->tofh, args->toname, args->tolen);
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_nfs_encode_hash(xdr, &args->hash, args->by_acl);
+ #endif
  }
  
  /*
***************
*** 2472,2477 ****
--- 2630,2639 ----
  	{ NFSERR_SERVERFAULT,	-EREMOTEIO	},
  	{ NFSERR_BADTYPE,	-EBADTYPE	},
  	{ NFSERR_JUKEBOX,	-EJUKEBOX	},
+ #ifdef CONFIG_NFS_V3_XATTR
+     { NFSERR_NODATA,    -ENODATA    }, //yxu
+     { NFSERR_RANGE,     -ERANGE     }, //yxu
+ #endif
  	{ -1,			-EIO		}
  };
  
***************
*** 2495,2500 ****
--- 2657,2775 ----
  }
  
  
+ #ifdef CONFIG_NFS_V3_XATTR
+ /*
+  * Decode GETXATTR reply
+  *
+  * FIXME: determine appropriate error returns
+  * yxu
+  */
+ static int nfs3_xdr_getxattrres(struct rpc_rqst *req,
+         struct xdr_stream *xdr,
+         struct nfs3_getxattrres *res)
+ {
+     __be32 *p;
+     char *xattr_val;
+     unsigned int xattr_max_size = res->xattr_val_len;
+     //yxu
+     //int status = ntohl(*p++);
+ 	enum nfs_stat status;
+ 	int error;
+     unsigned int tlen;
+ 
+ 	error = decode_nfsstat3(xdr, &status);
+     if (unlikely(error))
+         return error;
+ 
+     if (status != NFS3_OK)
+         return nfs3_stat_to_errno(status);
+ 
+     //	p = xdr_decode_post_op_attr(p, res->fattr);
+     //	yxu
+     if (decode_post_op_attr(xdr, res->fattr) != 0)
+         return -EIO;
+     if (xattr_max_size > 0) {
+         p = xdr_decode_string_inplace(xdr->p, &xattr_val,
+                 &res->xattr_val_len,
+                 xattr_max_size);
+     }
+     else {
+         p = xdr_decode_string_inplace(xdr->p, &xattr_val,
+                 &tlen,
+                 sizeof(res->xattr_val_len));
+     }
+     if (p == NULL)
+         return -EINVAL;
+     if (xattr_max_size > 0)
+         memcpy(res->xattr_val, xattr_val, res->xattr_val_len);
+     else
+         memcpy(&res->xattr_val_len, xattr_val, tlen);
+     //yxu
+     xdr->p = p;
+     return 0;
+ }
+ 
+ /*
+  * Decode SETXATTR reply
+  */
+ static int nfs3_xdr_setxattrres(struct rpc_rqst *req,
+         struct xdr_stream *xdr,
+ 				struct nfs3_setxattrres *res)
+ {
+   //yxu
+ //	int status = ntohl(*p++);
+ 	enum nfs_stat status;
+ 	int error;
+ 
+ 	error = decode_nfsstat3(xdr, &status);
+     if (unlikely(error))
+         return error;
+ 
+     if (status != NFS3_OK)
+         return nfs3_stat_to_errno(status);
+ 
+   //yxu
+ 	//xdr_decode_post_op_attr(p, res->fattr);
+     return decode_post_op_attr(xdr, res->fattr);
+ 	//return 0;
+ }
+ 
+ /*
+  * Decode LISTXATTR reply
+  */
+ static int nfs3_xdr_listxattrres(struct rpc_rqst *req,
+         struct xdr_stream *xdr,
+         struct nfs3_listxattrres *res)
+ {
+     __be32 *p;
+     char *xattr_list;
+     unsigned int size = res->xattr_list_len;
+     //yxu
+ 	//int status = ntohl(*p++);
+ 	enum nfs_stat status;
+ 	int error;
+ 
+ 	error = decode_nfsstat3(xdr, &status);
+     if (unlikely(error))
+         return error;
+ 
+     if (status != NFS3_OK)
+         return nfs3_stat_to_errno(status);
+ 
+ 	//p = xdr_decode_post_op_attr(p, res->fattr);
+ 	if (decode_post_op_attr(xdr, res->fattr))
+         return -EIO;
+ 	p = xdr_decode_string_inplace(xdr->p, &xattr_list,
+ 	                              &res->xattr_list_len, size);
+ 	if (p == NULL)
+ 		return -EINVAL;
+ 	memcpy(res->xattr_list, xattr_list, res->xattr_list_len);
+     //yxu
+     xdr->p = p;
+     return 0;
+ }
+ #endif	/* CONFIG_NFS_V3_XATTR */
+ 
  #define PROC(proc, argtype, restype, timer)				\
  [NFS3PROC_##proc] = {							\
  	.p_proc      = NFS3PROC_##proc,					\
***************
*** 2566,2568 ****
--- 2841,2881 ----
  	.procs			= nfs3_acl_procedures,
  };
  #endif  /* CONFIG_NFS_V3_ACL */
+ 
+ #ifdef CONFIG_NFS_V3_XATTR
+ static struct rpc_procinfo	nfs3_xattr_procedures[] = {
+ 	[XATTRPROC3_GETXATTR] = {
+ 		.p_proc		= XATTRPROC3_GETXATTR,
+ 		.p_encode	= (kxdreproc_t) nfs3_xdr_getxattrargs,
+ 		.p_decode	= (kxdrdproc_t) nfs3_xdr_getxattrres,
+ 		.p_arglen	= XATTR3_getxattrargs_sz,
+ 		.p_replen	= XATTR3_getxattrres_sz,
+ 		.p_timer	= 1,
+ 		.p_name		= "GETXATTR",
+ 	},
+ 	[XATTRPROC3_SETXATTR] = {
+ 		.p_proc		= XATTRPROC3_SETXATTR,
+ 		.p_encode	= (kxdreproc_t) nfs3_xdr_setxattrargs,
+ 		.p_decode	= (kxdrdproc_t) nfs3_xdr_setxattrres,
+ 		.p_arglen	= XATTR3_setxattrargs_sz,
+ 		.p_replen	= XATTR3_setxattrres_sz,
+ 		.p_timer	= 1,
+ 		.p_name		= "SETXATTR",
+ 	},
+ 	[XATTRPROC3_LISTXATTR] = {
+ 		.p_proc		= XATTRPROC3_LISTXATTR,
+ 		.p_encode	= (kxdreproc_t) nfs3_xdr_listxattrargs,
+ 		.p_decode	= (kxdrdproc_t) nfs3_xdr_listxattrres,
+ 		.p_arglen	= XATTR3_listxattrargs_sz,
+ 		.p_replen	= XATTR3_listxattrres_sz,
+ 		.p_timer	= 1,
+ 		.p_name		= "LISTXATTR",
+ 	},
+ };
+ 
+ struct rpc_version		nfs_xattr_version3 = {
+ 	.number			= 3,
+ 	.nrprocs		= ARRAY_SIZE(nfs3_xattr_procedures),
+ 	.procs			= nfs3_xattr_procedures,
+ };
+ #endif	/* CONFIG_NFS_V3_XATTR */
diff -crN orig/linux-3.5.4/fs/nfs/nfs_dcac.h linux-3.5.4/fs/nfs/nfs_dcac.h
*** orig/linux-3.5.4/fs/nfs/nfs_dcac.h	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/fs/nfs/nfs_dcac.h	2014-01-24 15:23:58.393584748 -0600
***************
*** 0 ****
--- 1,54 ----
+ #ifndef __NFS_DCAC__
+ #define __NFS_DCAC__
+ 
+ #include <linux/namei.h>
+ #include "../../security/dcac/include/hash.h"
+ #include "../../security/dcac/include/acl.h"
+ #include "../../security/dcac/include/file.h"
+ 
+ static inline void dcac_nfs_set_hash(struct inode *inode, dcac_hash_t *hash, int *by_acl) {
+   dcac_inode_sec_t *isec = inode->i_security;
+   if (isec->by_acl) {
+     dcac_calc_hash(isec->xattr, isec->xattr_size, hash);
+   }
+   *by_acl = isec->by_acl;
+ }
+ 
+ static inline void dcac_nfs_encode_hash(struct xdr_stream *xdr, const dcac_hash_t *hash, int by_acl) {
+ 	__be32 *p;
+   if (by_acl) {
+     p = xdr_reserve_space(xdr, 4 + DCAC_HASH_SZ);
+     xdr_encode_opaque(p, hash->hashval, DCAC_HASH_SZ);
+   } else {
+     p = xdr_reserve_space(xdr, 4);
+     *p++ = cpu_to_be32(0);
+   }
+ }
+ 
+ static inline void dcac_nfs_encode_def_acl(struct xdr_stream *xdr) {
+ 	__be32 *p;
+   char *xattr;
+   size_t xlen;
+   dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+ 
+   if (ctx->rdacl || ctx->wracl || ctx->exacl || ctx->mdacl) {
+     if (dcac_cat_4_acls(ctx, &xattr, &xlen) != 0) {
+       printk("DCAC: error allocating initial xattr for NFS\n");
+       xlen = 0;
+     }
+   } else {
+     xlen = 0;
+   }
+ 
+   if (xlen > 0) {
+     p = xdr_reserve_space(xdr, 4 + xlen);
+     xdr_encode_opaque(p, xattr, xlen);
+     kfree(xattr);
+   } else {
+     p = xdr_reserve_space(xdr, 4);
+     *p++ = cpu_to_be32(0);
+   }
+ }
+ 
+ 
+ #endif
diff -crN orig/linux-3.5.4/fs/nfs/super.c linux-3.5.4/fs/nfs/super.c
*** orig/linux-3.5.4/fs/nfs/super.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfs/super.c	2014-01-20 15:48:09.273333673 -0600
***************
*** 83,88 ****
--- 83,90 ----
  	Opt_lock, Opt_nolock,
  	Opt_udp, Opt_tcp, Opt_rdma,
  	Opt_acl, Opt_noacl,
+ 	Opt_xattr, Opt_noxattr,
+ 	Opt_xattrsec, Opt_noxattrsec,
  	Opt_rdirplus, Opt_nordirplus,
  	Opt_sharecache, Opt_nosharecache,
  	Opt_resvport, Opt_noresvport,
***************
*** 138,143 ****
--- 140,149 ----
  	{ Opt_rdma, "rdma" },
  	{ Opt_acl, "acl" },
  	{ Opt_noacl, "noacl" },
+ 	{ Opt_xattr, "xattr" },
+ 	{ Opt_noxattr, "noxattr" },
+ 	{ Opt_xattrsec, "xattrsec" },
+ 	{ Opt_noxattrsec, "noxattrsec" },
  	{ Opt_rdirplus, "rdirplus" },
  	{ Opt_nordirplus, "nordirplus" },
  	{ Opt_sharecache, "sharecache" },
***************
*** 940,945 ****
--- 946,952 ----
  
  	server = NFS_SB(sb);
  	/* -EIO all pending I/O */
+ 	/* FIXME: client_xattr ? */
  	rpc = server->client_acl;
  	if (!IS_ERR(rpc))
  		rpc_killall_tasks(rpc);
***************
*** 1268,1273 ****
--- 1275,1292 ----
  		case Opt_noacl:
  			mnt->flags |= NFS_MOUNT_NOACL;
  			break;
+ 		case Opt_xattr:
+ 			mnt->flags &= ~NFS_MOUNT_NOXATTR;
+ 			break;
+ 		case Opt_noxattr:
+ 			mnt->flags |= NFS_MOUNT_NOXATTR;
+ 			break;
+ 		case Opt_xattrsec:
+ 			mnt->flags |= NFS_MOUNT_XATTRSEC;
+ 			break;
+ 		case Opt_noxattrsec:
+ 			mnt->flags &= ~NFS_MOUNT_XATTRSEC;
+ 			break;
  		case Opt_rdirplus:
  			mnt->flags &= ~NFS_MOUNT_NORDIRPLUS;
  			break;
***************
*** 2212,2217 ****
--- 2231,2239 ----
  		 */
  		sb->s_flags |= MS_POSIXACL;
  		sb->s_time_gran = 1;
+ #ifdef CONFIG_NFS_V3_XATTR
+ 		sb->s_xattr = nfs3_xattr_handlers;
+ #endif
  	}
  
  	sb->s_op = &nfs_sops;
diff -crN orig/linux-3.5.4/fs/nfsd/Kconfig linux-3.5.4/fs/nfsd/Kconfig
*** orig/linux-3.5.4/fs/nfsd/Kconfig	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfsd/Kconfig	2014-01-20 15:48:09.273333673 -0600
***************
*** 64,69 ****
--- 64,77 ----
  
  	  If unsure, say N.
  
+ config NFSD_V3_XATTR
+ 	bool "NFS server support for the NFSv3 XATTR protocol extension (EXPERIMENTAL)"
+ 	depends on NFSD_V3 && EXPERIMENTAL
+ 	help
+ 	  NFS server support for the NFSv3 XATTR protocol.
+ 
+ 	  If unsure, say N.
+ 
  config NFSD_V4
  	bool "NFS server support for NFS version 4 (EXPERIMENTAL)"
  	depends on NFSD && PROC_FS && EXPERIMENTAL
diff -crN orig/linux-3.5.4/fs/nfsd/Makefile linux-3.5.4/fs/nfsd/Makefile
*** orig/linux-3.5.4/fs/nfsd/Makefile	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfsd/Makefile	2014-01-20 15:48:09.273333673 -0600
***************
*** 10,14 ****
--- 10,15 ----
  nfsd-$(CONFIG_NFSD_V2_ACL) += nfs2acl.o
  nfsd-$(CONFIG_NFSD_V3)	+= nfs3proc.o nfs3xdr.o
  nfsd-$(CONFIG_NFSD_V3_ACL) += nfs3acl.o
+ nfsd-$(CONFIG_NFSD_V3_XATTR) += nfs3xattr.o
  nfsd-$(CONFIG_NFSD_V4)	+= nfs4proc.o nfs4xdr.o nfs4state.o nfs4idmap.o \
  			   nfs4acl.o nfs4callback.o nfs4recover.o
diff -crN orig/linux-3.5.4/fs/nfsd/Module.symvers linux-3.5.4/fs/nfsd/Module.symvers
*** orig/linux-3.5.4/fs/nfsd/Module.symvers	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/fs/nfsd/Module.symvers	2014-01-20 15:48:09.273333673 -0600
***************
*** 0 ****
--- 1,5 ----
+ 0x35e33c1e	nfs4_acl_write_who	fs/nfsd/nfsd	EXPORT_SYMBOL
+ 0x5a157ae4	nfs4_acl_get_whotype	fs/nfsd/nfsd	EXPORT_SYMBOL
+ 0x2095976a	nfs4_acl_new	fs/nfsd/nfsd	EXPORT_SYMBOL
+ 0x0c8d6829	nfs4_acl_nfsv4_to_posix	fs/nfsd/nfsd	EXPORT_SYMBOL
+ 0xcbb738be	nfs4_acl_posix_to_nfsv4	fs/nfsd/nfsd	EXPORT_SYMBOL
diff -crN orig/linux-3.5.4/fs/nfsd/nfs3proc.c linux-3.5.4/fs/nfsd/nfs3proc.c
*** orig/linux-3.5.4/fs/nfsd/nfs3proc.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfsd/nfs3proc.c	2014-04-16 17:26:53.642014911 -0500
***************
*** 12,17 ****
--- 12,25 ----
  #include "xdr3.h"
  #include "vfs.h"
  
+ 
+ #ifdef CONFIG_SECURITY_DCAC
+ #include "nfsd_dcac.h"
+ #include "../../security/dcac/include/file.h"
+ #include "../../security/dcac/include/context.h"
+ #include <linux/namei.h>
+ #endif
+ 
  #define NFSDDBG_FACILITY		NFSDDBG_PROC
  
  #define RETURN_STATUS(st)	{ resp->status = (st); return (st); }
***************
*** 220,225 ****
--- 228,238 ----
  	svc_fh		*dirfhp, *newfhp = NULL;
  	struct iattr	*attr;
  	__be32		nfserr;
+ #ifdef CONFIG_SECURITY_DCAC
+   struct dentry *dentry;
+   struct inode *dir;
+   dcac_task_ctx_t *ctx;
+ #endif
  
  	dprintk("nfsd: CREATE(3)   %s %.*s\n",
  				SVCFH_fmt(&argp->fh),
***************
*** 244,253 ****
--- 257,278 ----
  		attr->ia_mode = (attr->ia_mode & ~S_IFMT) | S_IFREG;
  	}
  
+ #ifdef CONFIG_SECURITY_DCAC
+   dentry = dirfhp->fh_dentry;
+   dir = dentry->d_inode;
+   ctx = current_dcac_task_ctx();
+   if (dcac_nfsd_cmp_hash(dir, &argp->hash, argp->by_acl))
+ 		RETURN_STATUS(nfserrno(-EACCES));
+   dcac_set_default_encacl(ctx, argp->xattr, argp->xlen);
+ #endif
+ 
  	/* Now create the file and set attributes */
  	nfserr = do_nfsd_create(rqstp, dirfhp, argp->name, argp->len,
  				attr, newfhp,
  				argp->createmode, argp->verf, NULL, NULL);
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_set_default_encacl(ctx, NULL, 0);
+ #endif
  
  	RETURN_STATUS(nfserr);
  }
***************
*** 260,265 ****
--- 285,296 ----
  					 struct nfsd3_diropres   *resp)
  {
  	__be32	nfserr;
+ #ifdef CONFIG_SECURITY_DCAC
+   struct dentry *dentry;
+   struct inode *dir;
+   dcac_task_ctx_t *ctx;
+ 	svc_fh *dirfhp;
+ #endif
  
  	dprintk("nfsd: MKDIR(3)    %s %.*s\n",
  				SVCFH_fmt(&argp->fh),
***************
*** 267,276 ****
  				argp->name);
  
  	argp->attrs.ia_valid &= ~ATTR_SIZE;
! 	fh_copy(&resp->dirfh, &argp->fh);
  	fh_init(&resp->fh, NFS3_FHSIZE);
  	nfserr = nfsd_create(rqstp, &resp->dirfh, argp->name, argp->len,
  				    &argp->attrs, S_IFDIR, 0, &resp->fh);
  	fh_unlock(&resp->dirfh);
  	RETURN_STATUS(nfserr);
  }
--- 298,322 ----
  				argp->name);
  
  	argp->attrs.ia_valid &= ~ATTR_SIZE;
! 	dirfhp = fh_copy(&resp->dirfh, &argp->fh);
  	fh_init(&resp->fh, NFS3_FHSIZE);
+ 
+ #ifdef CONFIG_SECURITY_DCAC
+ 	fh_verify(rqstp, dirfhp, S_IFDIR, NFSD_MAY_CREATE);
+   dentry = dirfhp->fh_dentry;
+   dir = dentry->d_inode;
+   ctx = current_dcac_task_ctx();
+   if (dcac_nfsd_cmp_hash(dir, &argp->hash, argp->by_acl))
+ 		RETURN_STATUS(nfserrno(-EACCES));
+   dcac_set_default_encacl(ctx, argp->xattr, argp->xlen);
+ #endif
+ 
  	nfserr = nfsd_create(rqstp, &resp->dirfh, argp->name, argp->len,
  				    &argp->attrs, S_IFDIR, 0, &resp->fh);
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_set_default_encacl(ctx, NULL, 0);
+ #endif
+ 
  	fh_unlock(&resp->dirfh);
  	RETURN_STATUS(nfserr);
  }
***************
*** 280,296 ****
  					   struct nfsd3_diropres    *resp)
  {
  	__be32	nfserr;
  
  	dprintk("nfsd: SYMLINK(3)  %s %.*s -> %.*s\n",
  				SVCFH_fmt(&argp->ffh),
  				argp->flen, argp->fname,
  				argp->tlen, argp->tname);
  
! 	fh_copy(&resp->dirfh, &argp->ffh);
  	fh_init(&resp->fh, NFS3_FHSIZE);
  	nfserr = nfsd_symlink(rqstp, &resp->dirfh, argp->fname, argp->flen,
  						   argp->tname, argp->tlen,
  						   &resp->fh, &argp->attrs);
  	RETURN_STATUS(nfserr);
  }
  
--- 326,363 ----
  					   struct nfsd3_diropres    *resp)
  {
  	__be32	nfserr;
+ #ifdef CONFIG_SECURITY_DCAC
+   struct dentry *dentry;
+   struct inode *dir;
+   dcac_task_ctx_t *ctx;
+ 	svc_fh *dirfhp;
+ #endif
  
  	dprintk("nfsd: SYMLINK(3)  %s %.*s -> %.*s\n",
  				SVCFH_fmt(&argp->ffh),
  				argp->flen, argp->fname,
  				argp->tlen, argp->tname);
  
! 	dirfhp = fh_copy(&resp->dirfh, &argp->ffh);
  	fh_init(&resp->fh, NFS3_FHSIZE);
+ 
+ #ifdef CONFIG_SECURITY_DCAC
+ 	fh_verify(rqstp, dirfhp, S_IFDIR, NFSD_MAY_CREATE);
+   dentry = dirfhp->fh_dentry;
+   dir = dentry->d_inode;
+   ctx = current_dcac_task_ctx();
+   if (dcac_nfsd_cmp_hash(dir, &argp->hash, argp->by_acl))
+ 		RETURN_STATUS(nfserrno(-EACCES));
+   dcac_set_default_encacl(ctx, argp->xattr, argp->xlen);
+ #endif
+ 
  	nfserr = nfsd_symlink(rqstp, &resp->dirfh, argp->fname, argp->flen,
  						   argp->tname, argp->tlen,
  						   &resp->fh, &argp->attrs);
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_set_default_encacl(ctx, NULL, 0);
+ #endif
+ 
  	RETURN_STATUS(nfserr);
  }
  
***************
*** 304,317 ****
  	__be32	nfserr;
  	int type;
  	dev_t	rdev = 0;
  
  	dprintk("nfsd: MKNOD(3)    %s %.*s\n",
  				SVCFH_fmt(&argp->fh),
  				argp->len,
  				argp->name);
  
! 	fh_copy(&resp->dirfh, &argp->fh);
  	fh_init(&resp->fh, NFS3_FHSIZE);
  
  	if (argp->ftype == 0 || argp->ftype >= NF3BAD)
  		RETURN_STATUS(nfserr_inval);
--- 371,399 ----
  	__be32	nfserr;
  	int type;
  	dev_t	rdev = 0;
+ #ifdef CONFIG_SECURITY_DCAC
+   struct dentry *dentry;
+   struct inode *dir;
+   dcac_task_ctx_t *ctx;
+ 	svc_fh *dirfhp;
+ #endif
  
  	dprintk("nfsd: MKNOD(3)    %s %.*s\n",
  				SVCFH_fmt(&argp->fh),
  				argp->len,
  				argp->name);
  
! 	dirfhp = fh_copy(&resp->dirfh, &argp->fh);
  	fh_init(&resp->fh, NFS3_FHSIZE);
+ #ifdef CONFIG_SECURITY_DCAC
+ 	fh_verify(rqstp, dirfhp, S_IFDIR, NFSD_MAY_CREATE);
+   dentry = dirfhp->fh_dentry;
+   dir = dentry->d_inode;
+   ctx = current_dcac_task_ctx();
+   if (dcac_nfsd_cmp_hash(dir, &argp->hash, argp->by_acl))
+ 		RETURN_STATUS(nfserrno(-EACCES));
+   dcac_set_default_encacl(ctx, argp->xattr, argp->xlen);
+ #endif
  
  	if (argp->ftype == 0 || argp->ftype >= NF3BAD)
  		RETURN_STATUS(nfserr_inval);
***************
*** 327,332 ****
--- 409,417 ----
  	type = nfs3_ftypes[argp->ftype];
  	nfserr = nfsd_create(rqstp, &resp->dirfh, argp->name, argp->len,
  				    &argp->attrs, type, rdev, &resp->fh);
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_set_default_encacl(ctx, NULL, 0);
+ #endif
  	fh_unlock(&resp->dirfh);
  	RETURN_STATUS(nfserr);
  }
***************
*** 339,344 ****
--- 424,433 ----
  					  struct nfsd3_attrstat  *resp)
  {
  	__be32	nfserr;
+ #ifdef CONFIG_SECURITY_DCAC
+   struct inode *dir;
+ 	svc_fh *dirfhp;
+ #endif
  
  	dprintk("nfsd: REMOVE(3)   %s %.*s\n",
  				SVCFH_fmt(&argp->fh),
***************
*** 346,352 ****
  				argp->name);
  
  	/* Unlink. -S_IFDIR means file must not be a directory */
! 	fh_copy(&resp->fh, &argp->fh);
  	nfserr = nfsd_unlink(rqstp, &resp->fh, -S_IFDIR, argp->name, argp->len);
  	fh_unlock(&resp->fh);
  	RETURN_STATUS(nfserr);
--- 435,448 ----
  				argp->name);
  
  	/* Unlink. -S_IFDIR means file must not be a directory */
! 	dirfhp = fh_copy(&resp->fh, &argp->fh);
! #ifdef CONFIG_SECURITY_DCAC
! 	fh_verify(rqstp, dirfhp, S_IFDIR, NFSD_MAY_CREATE);
!   dir = dirfhp->fh_dentry->d_inode;
!   if (dcac_nfsd_cmp_hash(dir, &argp->hash, argp->by_acl))
! 		RETURN_STATUS(nfserrno(-EACCES));
! #endif
! 
  	nfserr = nfsd_unlink(rqstp, &resp->fh, -S_IFDIR, argp->name, argp->len);
  	fh_unlock(&resp->fh);
  	RETURN_STATUS(nfserr);
***************
*** 360,372 ****
  					 struct nfsd3_attrstat  *resp)
  {
  	__be32	nfserr;
  
  	dprintk("nfsd: RMDIR(3)    %s %.*s\n",
  				SVCFH_fmt(&argp->fh),
  				argp->len,
  				argp->name);
  
! 	fh_copy(&resp->fh, &argp->fh);
  	nfserr = nfsd_unlink(rqstp, &resp->fh, S_IFDIR, argp->name, argp->len);
  	fh_unlock(&resp->fh);
  	RETURN_STATUS(nfserr);
--- 456,478 ----
  					 struct nfsd3_attrstat  *resp)
  {
  	__be32	nfserr;
+ #ifdef CONFIG_SECURITY_DCAC
+   struct inode *dir;
+ 	svc_fh *dirfhp;
+ #endif
  
  	dprintk("nfsd: RMDIR(3)    %s %.*s\n",
  				SVCFH_fmt(&argp->fh),
  				argp->len,
  				argp->name);
  
! 	dirfhp = fh_copy(&resp->fh, &argp->fh);
! #ifdef CONFIG_SECURITY_DCAC
! 	fh_verify(rqstp, dirfhp, S_IFDIR, NFSD_MAY_CREATE);
!   dir = dirfhp->fh_dentry->d_inode;
!   if (dcac_nfsd_cmp_hash(dir, &argp->hash, argp->by_acl))
! 		RETURN_STATUS(nfserrno(-EACCES));
! #endif
  	nfserr = nfsd_unlink(rqstp, &resp->fh, S_IFDIR, argp->name, argp->len);
  	fh_unlock(&resp->fh);
  	RETURN_STATUS(nfserr);
***************
*** 377,382 ****
--- 483,493 ----
  					  struct nfsd3_renameres  *resp)
  {
  	__be32	nfserr;
+ #ifdef CONFIG_SECURITY_DCAC
+   struct dentry *fdentry, *tdentry;
+   struct inode *fdir, *tdir;
+ 	svc_fh *fdirfhp, *tdirfhp;
+ #endif
  
  	dprintk("nfsd: RENAME(3)   %s %.*s ->\n",
  				SVCFH_fmt(&argp->ffh),
***************
*** 387,394 ****
  				argp->tlen,
  				argp->tname);
  
! 	fh_copy(&resp->ffh, &argp->ffh);
! 	fh_copy(&resp->tfh, &argp->tfh);
  	nfserr = nfsd_rename(rqstp, &resp->ffh, argp->fname, argp->flen,
  				    &resp->tfh, argp->tname, argp->tlen);
  	RETURN_STATUS(nfserr);
--- 498,516 ----
  				argp->tlen,
  				argp->tname);
  
! 	fdirfhp = fh_copy(&resp->ffh, &argp->ffh);
! 	tdirfhp = fh_copy(&resp->tfh, &argp->tfh);
! #ifdef CONFIG_SECURITY_DCAC
! 	fh_verify(rqstp, fdirfhp, S_IFDIR, NFSD_MAY_CREATE);
! 	fh_verify(rqstp, tdirfhp, S_IFDIR, NFSD_MAY_CREATE);
!   fdentry = fdirfhp->fh_dentry;
!   fdir = fdentry->d_inode;
!   tdentry = tdirfhp->fh_dentry;
!   tdir = tdentry->d_inode;
!   if (dcac_nfsd_cmp_hash(fdir, &argp->old_hash, argp->old_by_acl)
!       ||dcac_nfsd_cmp_hash(tdir, &argp->new_hash, argp->new_by_acl))
! 		RETURN_STATUS(nfserrno(-EACCES));
! #endif
  	nfserr = nfsd_rename(rqstp, &resp->ffh, argp->fname, argp->flen,
  				    &resp->tfh, argp->tname, argp->tlen);
  	RETURN_STATUS(nfserr);
***************
*** 399,404 ****
--- 521,530 ----
  					struct nfsd3_linkres  *resp)
  {
  	__be32	nfserr;
+ #ifdef CONFIG_SECURITY_DCAC
+   struct inode *dir;
+ 	svc_fh *dirfhp;
+ #endif
  
  	dprintk("nfsd: LINK(3)     %s ->\n",
  				SVCFH_fmt(&argp->ffh));
***************
*** 408,414 ****
  				argp->tname);
  
  	fh_copy(&resp->fh,  &argp->ffh);
! 	fh_copy(&resp->tfh, &argp->tfh);
  	nfserr = nfsd_link(rqstp, &resp->tfh, argp->tname, argp->tlen,
  				  &resp->fh);
  	RETURN_STATUS(nfserr);
--- 534,547 ----
  				argp->tname);
  
  	fh_copy(&resp->fh,  &argp->ffh);
! 	dirfhp = fh_copy(&resp->tfh, &argp->tfh);
! #ifdef CONFIG_SECURITY_DCAC
! 	fh_verify(rqstp, dirfhp, S_IFDIR, NFSD_MAY_CREATE);
!   dir = dirfhp->fh_dentry->d_inode;
!   if (dcac_nfsd_cmp_hash(dir, &argp->hash, argp->by_acl))
! 		RETURN_STATUS(nfserrno(-EACCES));
! #endif
! 
  	nfserr = nfsd_link(rqstp, &resp->tfh, argp->tname, argp->tlen,
  				  &resp->fh);
  	RETURN_STATUS(nfserr);
diff -crN orig/linux-3.5.4/fs/nfsd/nfs3xattr.c linux-3.5.4/fs/nfsd/nfs3xattr.c
*** orig/linux-3.5.4/fs/nfsd/nfs3xattr.c	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/fs/nfsd/nfs3xattr.c	2014-01-24 15:08:22.157594463 -0600
***************
*** 0 ****
--- 1,393 ----
+ /*
+  * Process version 3 NFSXATTR requests.
+  *
+  * Based on the NFSACL code by:
+  * Copyright (C) 2002-2003 Andreas Gruenbacher <agruen@suse.de>
+  *
+  * Copyright (C) 2009 Red Hat, Inc., James Morris <jmorris@redhat.com>
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License version 2,
+  * as published by the Free Software Foundation.
+  */
+ #include <linux/sunrpc/svc.h>
+ #include <linux/nfs3.h>
+ #include <linux/xattr.h>
+ #include <linux/nfs_xattr.h>
+ 
+ #include "nfsd.h"
+ #include "xdr3.h"
+ #include "vfs.h"
+ #include "cache.h"
+ 
+ #define NFSDDBG_FACILITY	NFSDDBG_PROC
+ #define RETURN_STATUS(st)	{ resp->status = (st); return (st); }
+ 
+ /* NULL call */
+ static __be32 nfsd3_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)
+ {
+ 	return nfs_ok;
+ }
+ 
+ /*
+  * GETXATTR
+  *
+  * FIXME:
+  *  - Implement shared xattr cache
+  *  - Audit nfs error returns
+  */
+ static __be32 nfsd3_proc_getxattr(struct svc_rqst * rqstp,
+ 				  struct nfsd3_getxattrargs *argp,
+ 				  struct nfsd3_getxattrres *resp)
+ {
+ 	__be32 nfserr = nfserrno(-EINVAL);
+ 	svc_fh *fh;
+ 	void *value;
+ 	int ret;
+ 	char *name, *xattr_name = argp->xattr_name;
+ 	unsigned int size_max = argp->xattr_size_max;
+ 	unsigned int name_len = argp->xattr_name_len;
+ 	unsigned int name_tot_len = name_len + NFSD_XATTR_PREFIX_LEN;
+ 
+ 	dprintk("nfsd: GETXATTR(3)  %s %.*s %u\n", SVCFH_fmt(&argp->fh),
+ 	        name_len, xattr_name, size_max);
+ 
+ 	if (name_tot_len > XATTR_NAME_MAX)
+ 		RETURN_STATUS(nfserr);
+ 
+ 	if (size_max > XATTR_SIZE_MAX)
+ 		RETURN_STATUS(nfserr);
+ 
+     //yxu
+ #if 0
+ 	/* Probes must be handled by the client */
+ 	if (size_max == 0)
+ 		RETURN_STATUS(nfserr);
+ #endif
+     resp->xattr_size_max = size_max;
+ 
+ 	fh = fh_copy(&resp->fh, &argp->fh);
+ 	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_READ);
+ 	if (nfserr)
+ 		RETURN_STATUS(nfserr);
+ 
+ 	/* Convert xattr name to real string and add local prefix */
+ 	name = kmalloc(name_tot_len + 1, GFP_KERNEL);
+ 	if (name == NULL)
+ 		RETURN_STATUS(nfserrno(-ENOMEM));
+ 
+ 	ret = snprintf(name, name_tot_len + 1, "%s%.*s",
+ 		       NFSD_XATTR_PREFIX, name_len, xattr_name);
+ 	if (ret > name_tot_len) {
+ 		nfserr = nfserrno(-EINVAL);
+ 		goto cleanup;
+ 	}
+ 
+ 	ret = nfsd_getxattr2(fh->fh_dentry, name, &value, size_max); //yxu
+ 	if (ret <= 0) {
+ 		nfserr = nfserrno(ret);
+ 		goto cleanup;
+ 	}
+ 
+ 	nfserr = 0;
+ 	resp->xattr_val = value;
+ 	resp->xattr_val_len = ret;
+ 
+ 	/* FIXME: verify whether release func is called on error (cf. ACL code) */
+ 
+ cleanup:
+ 	kfree(name);
+ 	RETURN_STATUS(nfserr);
+ }
+ 
+ /* cribbed from decode pathname */
+ static __be32 *decode_xattrname(__be32 *p, char **namp, unsigned int *lenp)
+ {
+ 	char *name;
+ 	unsigned int i;
+ 
+ 	p = xdr_decode_string_inplace(p, namp, lenp, XATTR_NAME_MAX);
+ 	if (p != NULL)
+ 		for (i = 0, name = *namp; i < *lenp; i++, name++)
+ 			if (*name == '\0')
+ 				return NULL;
+ 	return p;
+ }
+ 
+ static int nfs3svc_decode_getxattrargs(struct svc_rqst *rqstp, __be32 *p,
+ 				       struct nfsd3_getxattrargs *argp)
+ {
+ 	if (!(p = nfs3svc_decode_fh(p, &argp->fh)))
+ 		return 0;
+ 	if (!(p = decode_xattrname(p, &argp->xattr_name, &argp->xattr_name_len)))
+ 		return 0;
+ 	argp->xattr_size_max = ntohl(*p++);
+ 	return xdr_argsize_check(rqstp, p);
+ }
+ 
+ static int nfs3svc_encode_getxattrres(struct svc_rqst *rqstp, __be32 *p,
+ 				      struct nfsd3_getxattrres *resp)
+ {
+ 	p = nfs3svc_encode_post_op_attr(rqstp, p, &resp->fh);
+ 	if (resp->status == 0) //yxu
+     {
+         if (resp->xattr_size_max > 0)
+             p = xdr_encode_array(p, resp->xattr_val, resp->xattr_val_len);
+         else
+             p = xdr_encode_array(p, &resp->xattr_val_len,
+                     sizeof(resp->xattr_val_len));
+     }
+ 	return xdr_ressize_check(rqstp, p);
+ }
+ 
+ static int nfs3svc_release_getxattr(struct svc_rqst *rqstp, __be32 *p,
+ 				    struct nfsd3_getxattrres *resp)
+ {
+ 	fh_put(&resp->fh);
+ 	kfree(resp->xattr_val);
+ 	return 1;
+ }
+ 
+ /*
+  * SETXATTR and RMXATTR
+  *
+  * RMXATTR is detected with zero buffer len and XATTR_REPLACE.
+  *
+  */
+ static __be32 nfsd3_proc_setxattr(struct svc_rqst * rqstp,
+ 				  struct nfsd3_setxattrargs *argp,
+ 				  struct nfsd3_setxattrres *resp)
+ {
+ 	__be32 nfserr = nfserrno(-EINVAL);
+ 	svc_fh *fh;
+ 	int ret;
+ 	char *name, *xattr_name = argp->xattr_name;
+ 	unsigned int name_len = argp->xattr_name_len;
+ 	unsigned int val_len = argp->xattr_val_len;
+ 	unsigned int flags = argp->xattr_flags;
+ 	unsigned int name_tot_len = name_len + NFSD_XATTR_PREFIX_LEN;
+ 
+ 	dprintk("nfsd: SETXATTR(3)  %s %.*s %u %#x\n", SVCFH_fmt(&argp->fh),
+ 		name_len, xattr_name, val_len, flags);
+ 
+ 	if (name_tot_len > XATTR_NAME_MAX)
+ 		RETURN_STATUS(nfserr);
+ 
+ 	if (val_len > XATTR_SIZE_MAX)
+ 		RETURN_STATUS(nfserr);
+ 
+ 	if (flags & ~(XATTR_CREATE|XATTR_REPLACE))
+ 		RETURN_STATUS(nfserr);
+ 
+ 	fh = fh_copy(&resp->fh, &argp->fh);
+ 	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
+ 	if (nfserr)
+ 		RETURN_STATUS(nfserr);
+ 
+ 	/* Convert xattr name to real string and add prefix */
+ 	name = kmalloc(name_tot_len + 1, GFP_KERNEL);
+ 	if (name == NULL)
+ 		RETURN_STATUS(nfserrno(-ENOMEM));
+ 
+ 	ret = snprintf(name, name_tot_len + 1, "%s%.*s",
+ 		       NFSD_XATTR_PREFIX, name_len, xattr_name);
+ 
+ 	if (ret > name_tot_len) {
+ 		nfserr = nfserrno(-EINVAL);
+ 		goto cleanup;
+ 	}
+ 
+ 	if (!val_len) {
+ 		if (flags & ~XATTR_REPLACE) {
+ 			nfserr = nfserrno(-EINVAL);
+ 			goto cleanup;
+ 		}
+ 		ret = vfs_removexattr(fh->fh_dentry, name);
+ 	} else
+ 		ret = vfs_setxattr(fh->fh_dentry, name,
+ 				   argp->xattr_val, val_len, flags);
+ 
+ 	nfserr = nfserrno(ret);
+ 
+ cleanup:
+ 	kfree(name);
+ 	RETURN_STATUS(nfserr);
+ }
+ 
+ static int nfs3svc_decode_setxattrargs(struct svc_rqst *rqstp, __be32 *p,
+ 				       struct nfsd3_setxattrargs *argp)
+ {
+ 	if (!(p = nfs3svc_decode_fh(p, &argp->fh)))
+ 		return 0;
+ 	if (!(p = decode_xattrname(p, &argp->xattr_name, &argp->xattr_name_len)))
+ 		return 0;
+ 	if (!(p = xdr_decode_string_inplace(p, &argp->xattr_val,
+ 					&argp->xattr_val_len, XATTR_SIZE_MAX)))
+ 		return 0;
+ 	argp->xattr_flags = ntohl(*p++);
+ 	return xdr_argsize_check(rqstp, p);
+ }
+ 
+ static int nfs3svc_encode_setxattrres(struct svc_rqst *rqstp, __be32 *p,
+ 				      struct nfsd3_setxattrres *resp)
+ {
+ 	p = nfs3svc_encode_post_op_attr(rqstp, p, &resp->fh);
+ 	return xdr_ressize_check(rqstp, p);
+ }
+ 
+ static int nfs3svc_release_setxattr(struct svc_rqst *rqstp, __be32 *p,
+ 				    struct nfsd3_setxattrres *resp)
+ {
+ 	fh_put(&resp->fh);
+ 	return 1;
+ }
+ 
+ /*
+  * Search the xattr list for those which match the local NFSD prefix. For
+  * each, strip the prefix and copy out the rest of the xattr.
+  */
+ static int nfsd3_filter_xattrs(const char *in, char *out, int i_len)
+ {
+ 	int i_idx = 0, o_idx = 0;
+ 
+ 	while (i_idx < i_len) {
+ 		const char *curr = in + i_idx;
+ 		int c_len = strlen(curr);
+ 
+ 		if (!strncmp(NFSD_XATTR_PREFIX, curr, NFSD_XATTR_PREFIX_LEN)) {
+ 			strcpy(out + o_idx, curr + NFSD_XATTR_PREFIX_LEN);
+ 			o_idx += c_len - NFSD_XATTR_PREFIX_LEN + 1;
+ 		}
+ 
+ 		i_idx += c_len + 1;
+ 	}
+ 
+ 	return o_idx;
+ }
+ 
+ /*
+  * LISTXATTR
+  */
+ static __be32 nfsd3_proc_listxattr(struct svc_rqst * rqstp,
+ 				   struct nfsd3_listxattrargs *argp,
+ 				   struct nfsd3_listxattrres *resp)
+ {
+ 	__be32 nfserr = nfserrno(-EINVAL);
+ 	svc_fh *fh;
+ 	char *list, *f_list;
+ 	int ret, f_len;
+ 	unsigned int list_max = argp->xattr_list_max;
+ 
+ 	dprintk("nfsd: LISTXATTR(3)  %s %u\n", SVCFH_fmt(&argp->fh), list_max);
+ 
+ 	if (list_max > XATTR_LIST_MAX)
+ 		RETURN_STATUS(nfserr);
+ 
+ 	/* Probes must be handled by the client */
+ 	if (list_max == 0)
+ 		RETURN_STATUS(nfserr);
+ 
+ 	fh = fh_copy(&resp->fh, &argp->fh);
+ 	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_READ);
+ 	if (nfserr)
+ 		RETURN_STATUS(nfserr);
+ 
+ 	list = kmalloc(list_max, GFP_ATOMIC);
+ 	if (list == NULL)
+ 		RETURN_STATUS(nfserrno(-ENOMEM));
+ 
+ 	ret = vfs_listxattr(fh->fh_dentry, list, list_max);
+ 	if (ret <= 0) {
+ 		if (ret == 0)
+ 			ret = -ENODATA;
+ 		kfree(list);
+ 		RETURN_STATUS(nfserrno(ret));
+ 	}
+ 
+ 	/*
+ 	 * Filter the xattr list: translate and return only those stored
+ 	 * with the correct prefix.  The list is a series of nul-terminated
+ 	 * strings.
+ 	 */
+ 	f_list = kmalloc(ret, GFP_ATOMIC);
+ 	if (f_list == NULL) {
+ 		kfree(list);
+ 		RETURN_STATUS(nfserrno(-ENOMEM));
+ 	}
+ 
+ 	f_len = nfsd3_filter_xattrs(list, f_list, ret);
+ 	kfree(list);
+ 
+ 	nfserr = 0;
+ 	resp->xattr_list = f_list;
+ 	resp->xattr_list_len = f_len;
+ 
+ 	RETURN_STATUS(nfserr);
+ }
+ 
+ static int nfs3svc_decode_listxattrargs(struct svc_rqst *rqstp, __be32 *p,
+ 				        struct nfsd3_listxattrargs *argp)
+ {
+ 	if (!(p = nfs3svc_decode_fh(p, &argp->fh)))
+ 		return 0;
+ 	argp->xattr_list_max = ntohl(*p++);
+ 	return xdr_argsize_check(rqstp, p);
+ }
+ 
+ static int nfs3svc_encode_listxattrres(struct svc_rqst *rqstp, __be32 *p,
+ 				       struct nfsd3_listxattrres *resp)
+ {
+ 	p = nfs3svc_encode_post_op_attr(rqstp, p, &resp->fh);
+ 	if (resp->status == 0)
+ 		p = xdr_encode_array(p, resp->xattr_list, resp->xattr_list_len);
+ 	return xdr_ressize_check(rqstp, p);
+ }
+ 
+ static int nfs3svc_release_listxattr(struct svc_rqst *rqstp, __be32 *p,
+ 				     struct nfsd3_listxattrres *resp)
+ {
+ 	fh_put(&resp->fh);
+ 	kfree(resp->xattr_list);
+ 	return 1;
+ }
+ 
+ #define ST 1		/* status */
+ #define AT 21           /* attributes */
+ #define pAT (1+AT)      /* post attributes - conditional */
+ 
+ #define nfs3svc_decode_voidargs		NULL
+ #define nfs3svc_release_void		NULL
+ #define nfsd3_voidres			nfsd3_voidargs
+ struct nfsd3_voidargs { int dummy; };
+ 
+ #define PROC(name, argt, rest, relt, cache, respsize)	\
+  { (svc_procfunc) nfsd3_proc_##name,		\
+    (kxdrproc_t) nfs3svc_decode_##argt##args,	\
+    (kxdrproc_t) nfs3svc_encode_##rest##res,	\
+    (kxdrproc_t) nfs3svc_release_##relt,		\
+    sizeof(struct nfsd3_##argt##args),		\
+    sizeof(struct nfsd3_##rest##res),		\
+    0,						\
+    cache,					\
+    respsize,					\
+  }
+ 
+ #define G_RSZ	(ST+pAT+1+(XATTR_SIZE_MAX>>2))
+ #define S_RSZ	(ST+pAT)
+ #define L_RSZ	(ST+pAT+1+(XATTR_LIST_MAX>>2))
+ 
+ static struct svc_procedure nfsd_xattr_procedures3[] = {
+   PROC(null,       void,       void,       void,       RC_NOCACHE, ST),
+   PROC(getxattr,   getxattr,   getxattr,   getxattr,   RC_NOCACHE, G_RSZ),
+   PROC(setxattr,   setxattr,   setxattr,   setxattr,   RC_NOCACHE, S_RSZ),
+   PROC(listxattr,  listxattr,  listxattr,  listxattr,  RC_NOCACHE, L_RSZ),
+ };
+ 
+ struct svc_version	nfsd_xattr_version3 = {
+ 	.vs_vers	= 3,
+ 	.vs_nproc	= 4,
+ 	.vs_proc	= nfsd_xattr_procedures3,
+ 	.vs_dispatch	= nfsd_dispatch,
+ 	.vs_xdrsize	= NFS3_SVC_XDRSIZE,
+ 	.vs_hidden	= 1,
+ };
diff -crN orig/linux-3.5.4/fs/nfsd/nfs3xdr.c linux-3.5.4/fs/nfsd/nfs3xdr.c
*** orig/linux-3.5.4/fs/nfsd/nfs3xdr.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfsd/nfs3xdr.c	2014-04-11 01:40:53.959533075 -0500
***************
*** 12,17 ****
--- 12,20 ----
  
  #define NFSDDBG_FACILITY		NFSDDBG_XDR
  
+ #ifdef CONFIG_SECURITY_DCAC
+ #include "nfsd_dcac.h"
+ #endif
  
  /*
   * Mapping of S_IF* types to NFS file types
***************
*** 300,307 ****
  nfs3svc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,
  					struct nfsd3_diropargs *args)
  {
! 	if (!(p = decode_fh(p, &args->fh))
  	 || !(p = decode_filename(p, &args->name, &args->len)))
  		return 0;
  
  	return xdr_argsize_check(rqstp, p);
--- 303,315 ----
  nfs3svc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,
  					struct nfsd3_diropargs *args)
  {
!     if (!(p = decode_fh(p, &args->fh))
! #ifdef CONFIG_SECURITY_DCAC
! 	 || !(p = decode_filename(p, &args->name, &args->len))
!    || !(p = dcac_nfsd_decode_hash(p, &args->hash, &args->by_acl)))
! #else
  	 || !(p = decode_filename(p, &args->name, &args->len)))
+ #endif
  		return 0;
  
  	return xdr_argsize_check(rqstp, p);
***************
*** 409,415 ****
--- 417,429 ----
  					struct nfsd3_createargs *args)
  {
  	if (!(p = decode_fh(p, &args->fh))
+ #ifdef CONFIG_SECURITY_DCAC
+ 	 || !(p = decode_filename(p, &args->name, &args->len))
+      || !(p = dcac_nfsd_decode_hash(p, &args->hash, &args->by_acl))
+      || !(p = dcac_nfsd_decode_def_acl(p, &args->xattr, &args->xlen)))
+ #else
  	 || !(p = decode_filename(p, &args->name, &args->len)))
+ #endif
  		return 0;
  
  	switch (args->createmode = ntohl(*p++)) {
***************
*** 431,438 ****
  nfs3svc_decode_mkdirargs(struct svc_rqst *rqstp, __be32 *p,
  					struct nfsd3_createargs *args)
  {
! 	if (!(p = decode_fh(p, &args->fh)) ||
! 	    !(p = decode_filename(p, &args->name, &args->len)))
  		return 0;
  	p = decode_sattr3(p, &args->attrs);
  
--- 445,458 ----
  nfs3svc_decode_mkdirargs(struct svc_rqst *rqstp, __be32 *p,
  					struct nfsd3_createargs *args)
  {
!     if (!(p = decode_fh(p, &args->fh))
! #ifdef CONFIG_SECURITY_DCAC
! 	 || !(p = decode_filename(p, &args->name, &args->len))
!      || !(p = dcac_nfsd_decode_hash(p, &args->hash, &args->by_acl))
!      || !(p = dcac_nfsd_decode_def_acl(p, &args->xattr, &args->xlen)))
! #else
! 	 || !(p = decode_filename(p, &args->name, &args->len)))
! #endif
  		return 0;
  	p = decode_sattr3(p, &args->attrs);
  
***************
*** 448,455 ****
--- 468,481 ----
  	struct kvec *vec;
  
  	if (!(p = decode_fh(p, &args->ffh)) ||
+ #ifdef CONFIG_SECURITY_DCAC
+ 	 !(p = decode_filename(p, &args->fname, &args->flen))
+    || !(p = dcac_nfsd_decode_hash(p, &args->hash, &args->by_acl))
+    || !(p = dcac_nfsd_decode_def_acl(p, &args->xattr, &args->xlen)))
+ #else
  	    !(p = decode_filename(p, &args->fname, &args->flen))
  		)
+ #endif
  		return 0;
  	p = decode_sattr3(p, &args->attrs);
  
***************
*** 497,503 ****
--- 523,535 ----
  					struct nfsd3_mknodargs *args)
  {
  	if (!(p = decode_fh(p, &args->fh))
+ #ifdef CONFIG_SECURITY_DCAC
+ 	 || !(p = decode_filename(p, &args->name, &args->len))
+    || !(p = dcac_nfsd_decode_hash(p, &args->hash, &args->by_acl))
+    || !(p = dcac_nfsd_decode_def_acl(p, &args->xattr, &args->xlen)))
+ #else
  	 || !(p = decode_filename(p, &args->name, &args->len)))
+ #endif
  		return 0;
  
  	args->ftype = ntohl(*p++);
***************
*** 521,527 ****
  	if (!(p = decode_fh(p, &args->ffh))
  	 || !(p = decode_filename(p, &args->fname, &args->flen))
  	 || !(p = decode_fh(p, &args->tfh))
! 	 || !(p = decode_filename(p, &args->tname, &args->tlen)))
  		return 0;
  
  	return xdr_argsize_check(rqstp, p);
--- 553,564 ----
  	if (!(p = decode_fh(p, &args->ffh))
  	 || !(p = decode_filename(p, &args->fname, &args->flen))
  	 || !(p = decode_fh(p, &args->tfh))
! 	 || !(p = decode_filename(p, &args->tname, &args->tlen))
! #ifdef CONFIG_SECURITY_DCAC
!    || !(p = dcac_nfsd_decode_hash(p, &args->old_hash, &args->old_by_acl))
!    || !(p = dcac_nfsd_decode_hash(p, &args->new_hash, &args->new_by_acl))
! #endif
!    )
  		return 0;
  
  	return xdr_argsize_check(rqstp, p);
***************
*** 545,551 ****
--- 582,593 ----
  {
  	if (!(p = decode_fh(p, &args->ffh))
  	 || !(p = decode_fh(p, &args->tfh))
+ #ifdef CONFIG_SECURITY_DCAC
+ 	 || !(p = decode_filename(p, &args->tname, &args->tlen))
+    || !(p = dcac_nfsd_decode_hash(p, &args->hash, &args->by_acl)))
+ #else
  	 || !(p = decode_filename(p, &args->tname, &args->tlen)))
+ #endif
  		return 0;
  
  	return xdr_argsize_check(rqstp, p);
diff -crN orig/linux-3.5.4/fs/nfsd/nfsctl.c linux-3.5.4/fs/nfsd/nfsctl.c
*** orig/linux-3.5.4/fs/nfsd/nfsctl.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfsd/nfsctl.c	2014-01-20 15:48:09.273333673 -0600
***************
*** 1175,1180 ****
--- 1175,1182 ----
  	.size = sizeof(struct nfsd_net),
  };
  
+ extern void __init nfsd_prog_init(void);
+ 
  static int __init init_nfsd(void)
  {
  	int retval;
***************
*** 1193,1198 ****
--- 1195,1201 ----
  	retval = nfsd_fault_inject_init(); /* nfsd fault injection controls */
  	if (retval)
  		goto out_free_slabs;
+ 	nfsd_prog_init();
  	nfsd_stat_init();	/* Statistics */
  	retval = nfsd_reply_cache_init();
  	if (retval)
diff -crN orig/linux-3.5.4/fs/nfsd/nfsd_dcac.h linux-3.5.4/fs/nfsd/nfsd_dcac.h
*** orig/linux-3.5.4/fs/nfsd/nfsd_dcac.h	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/fs/nfsd/nfsd_dcac.h	2014-04-11 01:50:00.311515970 -0500
***************
*** 0 ****
--- 1,88 ----
+ #ifndef __NFSD_DCAC__
+ #define __NFSD_DCAC__
+ 
+ #include <linux/namei.h>
+ #include <linux/slab.h>
+ #include <linux/string.h>
+ #include <linux/xattr.h>
+ #include <linux/cred.h>
+ 
+ #include "../../security/dcac/include/hash.h"
+ #include "../../security/dcac/include/file.h"
+ 
+ static inline int dcac_nfsd_cmp_hash(struct inode *inode, const dcac_hash_t *c_hash, int by_acl) {
+   dcac_hash_t s_hash;
+   char *s_xattr = NULL;
+   int s_xattr_size = -1;
+   unsigned int mode = inode->i_mode;
+ 
+   if (!by_acl) {
+     if (uid_eq(current_fsuid(), inode->i_uid))
+       mode >>= 6;
+     else if (in_group_p(inode->i_gid))
+       mode >>= 3;
+ 
+     if ((MAY_WRITE & ~mode) == 0)
+       return 0;
+     return -EACCES;
+   }
+ 
+   s_xattr = kmalloc(4096, GFP_NOFS);
+   if (!s_xattr)
+     return -ENOMEM;
+ 
+   s_xattr_size = dcac_getxattr(NULL, inode, DCAC_FATTR_NAME_PM, s_xattr, 4096);
+   if (s_xattr_size <= 0)
+     return -EACCES;
+   dcac_calc_hash(s_xattr, s_xattr_size, &s_hash);
+   kfree(s_xattr);
+ 
+   return dcac_hash_cmp(&s_hash, c_hash);
+ }
+ 
+ static inline __be32 *
+ dcac_nfsd_decode_hash(__be32 *p, dcac_hash_t *hash, unsigned int *by_acl)
+ {
+ 	char *hashp;
+   int len;
+ 
+ 	if ((p = xdr_decode_string_inplace(p, &hashp, &len, 128)) != NULL) {
+     if (len > 0) {
+       memcpy(hash->hashval, hashp, DCAC_HASH_SZ);
+       *by_acl = 1;
+     } else
+       *by_acl = 0;
+ 	}
+ 
+ 	return p;
+ }
+ 
+ static inline __be32 *
+ dcac_nfsd_decode_def_acl(__be32 *p, char **xattr, int *xlen)
+ {
+ 	char *buf;
+   int len;
+ 
+ 	if ((p = xdr_decode_string_inplace(p, &buf, &len, 4096)) != NULL) {
+     if (len > 0) {
+       /*
+       *xattr = kmalloc(len, GFP_KERNEL);
+       if (*xattr)
+         *xlen = len;
+       else
+         *xlen = 0;
+       memcpy(*xattr, buf, *xlen);
+       */
+       *xattr = buf;
+       *xlen = len;
+     } else {
+       *xlen = 0;
+       *xattr = NULL;
+     }
+ 	}
+ 
+ 	return p;
+ }
+ 
+ 
+ #endif
diff -crN orig/linux-3.5.4/fs/nfsd/nfsd.h linux-3.5.4/fs/nfsd/nfsd.h
*** orig/linux-3.5.4/fs/nfsd/nfsd.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfsd/nfsd.h	2014-01-20 15:48:09.273333673 -0600
***************
*** 148,153 ****
--- 148,154 ----
  #define	nfserr_nospc		cpu_to_be32(NFSERR_NOSPC)
  #define	nfserr_rofs		cpu_to_be32(NFSERR_ROFS)
  #define	nfserr_mlink		cpu_to_be32(NFSERR_MLINK)
+ #define	nfserr_range		cpu_to_be32(NFSERR_RANGE)
  #define	nfserr_opnotsupp	cpu_to_be32(NFSERR_OPNOTSUPP)
  #define	nfserr_nametoolong	cpu_to_be32(NFSERR_NAMETOOLONG)
  #define	nfserr_notempty		cpu_to_be32(NFSERR_NOTEMPTY)
***************
*** 196,201 ****
--- 197,203 ----
  #define	nfserr_cb_path_down	cpu_to_be32(NFSERR_CB_PATH_DOWN)
  #define	nfserr_locked		cpu_to_be32(NFSERR_LOCKED)
  #define	nfserr_wrongsec		cpu_to_be32(NFSERR_WRONGSEC)
+ #define nfserr_nodata			cpu_to_be32(NFSERR_NODATA)
  #define nfserr_badiomode		cpu_to_be32(NFS4ERR_BADIOMODE)
  #define nfserr_badlayout		cpu_to_be32(NFS4ERR_BADLAYOUT)
  #define nfserr_bad_session_digest	cpu_to_be32(NFS4ERR_BAD_SESSION_DIGEST)
diff -crN orig/linux-3.5.4/fs/nfsd/nfsproc.c linux-3.5.4/fs/nfsd/nfsproc.c
*** orig/linux-3.5.4/fs/nfsd/nfsproc.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfsd/nfsproc.c	2014-01-20 15:48:09.273333673 -0600
***************
*** 742,747 ****
--- 742,751 ----
  		{ nfserr_notsupp, -EOPNOTSUPP },
  		{ nfserr_toosmall, -ETOOSMALL },
  		{ nfserr_serverfault, -ESERVERFAULT },
+ #ifdef CONFIG_NFSD_V3_XATTR
+ 		{ nfserr_nodata, -ENODATA },
+ 		{ nfserr_range, -ERANGE },
+ #endif
  	};
  	int	i;
  
diff -crN orig/linux-3.5.4/fs/nfsd/nfssvc.c linux-3.5.4/fs/nfsd/nfssvc.c
*** orig/linux-3.5.4/fs/nfsd/nfssvc.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfsd/nfssvc.c	2014-01-20 15:48:09.277333673 -0600
***************
*** 17,22 ****
--- 17,23 ----
  #include <linux/sunrpc/svcsock.h>
  #include <linux/lockd/bind.h>
  #include <linux/nfsacl.h>
+ #include <linux/nfs_xattr.h>
  #include <linux/seq_file.h>
  #include <net/net_namespace.h>
  #include "nfsd.h"
***************
*** 90,95 ****
--- 91,117 ----
  };
  #endif /* defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL) */
  
+ #ifdef CONFIG_NFSD_V3_XATTR
+ static struct svc_stat	nfsd_xattr_svcstats;
+ static struct svc_version *	nfsd_xattr_version[] = {
+ 	[3] = &nfsd_xattr_version3,
+ };
+ 
+ #define NFSD_XATTR_MINVERS	3
+ #define NFSD_XATTR_NRVERS	ARRAY_SIZE(nfsd_xattr_version)
+ static struct svc_version *nfsd_xattr_versions[NFSD_XATTR_NRVERS];
+ 
+ static struct svc_program	nfsd_xattr_program = {
+ 	.pg_prog		= NFS_XATTR_PROGRAM,
+ 	.pg_nvers		= NFSD_XATTR_NRVERS,
+ 	.pg_vers		= nfsd_xattr_versions,
+ 	.pg_name		= "nfsxattr",
+ 	.pg_class		= "nfsd",		/* share nfsd auth */
+ 	.pg_stats		= &nfsd_xattr_svcstats,
+ 	.pg_authenticate	= &svc_set_client,
+ };
+ #endif	/* CONFIG_NFSD_V3_XATTR */
+ 
  static struct svc_version *	nfsd_version[] = {
  	[2] = &nfsd_version2,
  #if defined(CONFIG_NFSD_V3)
***************
*** 105,113 ****
  static struct svc_version *nfsd_versions[NFSD_NRVERS];
  
  struct svc_program		nfsd_program = {
- #if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)
- 	.pg_next		= &nfsd_acl_program,
- #endif
  	.pg_prog		= NFS_PROGRAM,		/* program number */
  	.pg_nvers		= NFSD_NRVERS,		/* nr of entries in nfsd_version */
  	.pg_vers		= nfsd_versions,	/* version table */
--- 127,132 ----
***************
*** 118,123 ****
--- 137,164 ----
  
  };
  
+ static void __init nfsd_prog_add(struct svc_program *new)
+ {
+ 	struct svc_program *p = &nfsd_program;
+ 
+ 	while (p->pg_next)
+ 		p = p->pg_next;
+ 
+ 	p->pg_next = new;
+ }
+ 
+ /* Dynamically initialize list of service programs */
+ void __init nfsd_prog_init(void)
+ {
+ #if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)
+ 	nfsd_prog_add(&nfsd_acl_program);
+ #endif
+ 
+ #ifdef CONFIG_NFSD_V3_XATTR
+ 	nfsd_prog_add(&nfsd_xattr_program);
+ #endif
+ }
+ 
  u32 nfsd_supported_minorversion;
  
  int nfsd_vers(int vers, enum vers_op change)
***************
*** 131,136 ****
--- 172,181 ----
  		if (vers < NFSD_ACL_NRVERS)
  			nfsd_acl_versions[vers] = nfsd_acl_version[vers];
  #endif
+ #ifdef CONFIG_NFSD_V3_XATTR
+ 		if (vers < NFSD_XATTR_NRVERS)
+ 			nfsd_xattr_versions[vers] = nfsd_xattr_version[vers];
+ #endif
  		break;
  	case NFSD_CLEAR:
  		nfsd_versions[vers] = NULL;
***************
*** 138,143 ****
--- 183,192 ----
  		if (vers < NFSD_ACL_NRVERS)
  			nfsd_acl_versions[vers] = NULL;
  #endif
+ #ifdef CONFIG_NFSD_V3_XATTR
+ 		if (vers < NFSD_XATTR_NRVERS)
+ 			nfsd_xattr_versions[vers] = NULL;
+ #endif
  		break;
  	case NFSD_TEST:
  		return nfsd_versions[vers] != NULL;
***************
*** 283,288 ****
--- 332,342 ----
  			nfsd_acl_program.pg_vers[i] =
  				nfsd_acl_version[i];
  #endif
+ #ifdef CONFIG_NFSD_V3_XATTR
+ 		for (i = NFSD_XATTR_MINVERS; i < NFSD_XATTR_NRVERS; i++)
+ 			nfsd_xattr_program.pg_vers[i] =
+ 				nfsd_xattr_version[i];
+ #endif
  	}
  }
  
diff -crN orig/linux-3.5.4/fs/nfsd/vfs.c linux-3.5.4/fs/nfsd/vfs.c
*** orig/linux-3.5.4/fs/nfsd/vfs.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfsd/vfs.c	2014-01-24 19:09:43.225444196 -0600
***************
*** 444,451 ****
  
  #if defined(CONFIG_NFSD_V2_ACL) || \
      defined(CONFIG_NFSD_V3_ACL) || \
!     defined(CONFIG_NFSD_V4)
! static ssize_t nfsd_getxattr(struct dentry *dentry, char *key, void **buf)
  {
  	ssize_t buflen;
  	ssize_t ret;
--- 444,470 ----
  
  #if defined(CONFIG_NFSD_V2_ACL) || \
      defined(CONFIG_NFSD_V3_ACL) || \
!     defined(CONFIG_NFSD_V4) || \
!     defined(CONFIG_NFSD_V3_XATTR)
! //yxu
! ssize_t nfsd_getxattr2(struct dentry *dentry, char *key,
!         void **buf, size_t size)
! {
! 	ssize_t ret;
! 
!     if (size > 0) {
!         *buf = kmalloc(size, GFP_KERNEL);
!         if (!*buf)
!             return -ENOMEM;
!     }
! 
! 	ret = vfs_getxattr(dentry, key, *buf, size);
! 	if (ret < 0 && size > 0)
! 		kfree(*buf);
! 	return ret;
! }
! 
! ssize_t nfsd_getxattr(struct dentry *dentry, char *key, void **buf)
  {
  	ssize_t buflen;
  	ssize_t ret;
***************
*** 454,462 ****
  	if (buflen <= 0)
  		return buflen;
  
! 	*buf = kmalloc(buflen, GFP_KERNEL);
! 	if (!*buf)
! 		return -ENOMEM;
  
  	ret = vfs_getxattr(dentry, key, *buf, buflen);
  	if (ret < 0)
--- 473,481 ----
  	if (buflen <= 0)
  		return buflen;
  
!     *buf = kmalloc(buflen, GFP_KERNEL);
!     if (!*buf)
!         return -ENOMEM;
  
  	ret = vfs_getxattr(dentry, key, *buf, buflen);
  	if (ret < 0)
diff -crN orig/linux-3.5.4/fs/nfsd/vfs.h linux-3.5.4/fs/nfsd/vfs.h
*** orig/linux-3.5.4/fs/nfsd/vfs.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfsd/vfs.h	2014-01-20 15:48:09.277333673 -0600
***************
*** 118,121 ****
--- 118,145 ----
  	mnt_drop_write(fh->fh_export->ex_path.mnt);
  }
  
+ #if defined(CONFIG_NFSD_V2_ACL) || \
+     defined(CONFIG_NFSD_V3_ACL) || \
+     defined(CONFIG_NFSD_V4) || \
+     defined(CONFIG_NFSD_V3_XATTR)
+ ssize_t nfsd_getxattr2(struct dentry *dentry, char *key, void **buf, size_t s);
+ ssize_t nfsd_getxattr(struct dentry *dentry, char *key, void **buf);
+ #endif
+ 
+ #ifdef CONFIG_NFSD_V3_XATTR
+ extern struct svc_version nfsd_xattr_version3;
+ 
+ /*
+  * Translation prefix for local storage of remote xattrs.  This is currently
+  * hard-coded, but could be made a configurable per-export option.  We're
+  * using the user namespace, which is widely supported by filesystems, and
+  * allows arbitrary manipulation.
+  */
+ #define NFSD_XATTR_PREFIX ""  //yxu: removed "nfsd."
+ #define NFSD_XATTR_PREFIX_LEN 0
+ 
+ #else
+ #define nfsd_xattr_version3 NULL
+ #endif
+ 
  #endif /* LINUX_NFSD_VFS_H */
diff -crN orig/linux-3.5.4/fs/nfsd/xdr3.h linux-3.5.4/fs/nfsd/xdr3.h
*** orig/linux-3.5.4/fs/nfsd/xdr3.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/nfsd/xdr3.h	2014-04-11 01:29:56.287553667 -0500
***************
*** 8,13 ****
--- 8,18 ----
  #define _LINUX_NFSD_XDR3_H
  
  #include "xdr.h"
+ #include <linux/time.h>
+ 
+ #ifdef CONFIG_SECURITY_DCAC
+ #include "../../security/dcac/include/hash.h"
+ #endif
  
  struct nfsd3_sattrargs {
  	struct svc_fh		fh;
***************
*** 20,25 ****
--- 25,34 ----
  	struct svc_fh		fh;
  	char *			name;
  	unsigned int		len;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t hash;
+   int by_acl;
+ #endif
  };
  
  struct nfsd3_accessargs {
***************
*** 47,52 ****
--- 56,67 ----
  	struct svc_fh		fh;
  	char *			name;
  	unsigned int		len;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t hash;
+   int by_acl;
+   char *xattr;
+   int xlen;
+ #endif
  	int			createmode;
  	struct iattr		attrs;
  	__be32 *		verf;
***************
*** 59,64 ****
--- 74,85 ----
  	__u32			ftype;
  	__u32			major, minor;
  	struct iattr		attrs;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t hash;
+   int by_acl;
+   char *xattr;
+   int xlen;
+ #endif
  };
  
  struct nfsd3_renameargs {
***************
*** 68,73 ****
--- 89,100 ----
  	struct svc_fh		tfh;
  	char *			tname;
  	unsigned int		tlen;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t old_hash;
+   dcac_hash_t new_hash;
+   int old_by_acl;
+   int new_by_acl;
+ #endif
  };
  
  struct nfsd3_readlinkargs {
***************
*** 80,85 ****
--- 107,116 ----
  	struct svc_fh		tfh;
  	char *			tname;
  	unsigned int		tlen;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t hash;
+   int by_acl;
+ #endif
  };
  
  struct nfsd3_symlinkargs {
***************
*** 89,94 ****
--- 120,131 ----
  	char *			tname;
  	unsigned int		tlen;
  	struct iattr		attrs;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t hash;
+   int by_acl;
+   char *xattr;
+   int xlen;
+ #endif
  };
  
  struct nfsd3_readdirargs {
***************
*** 119,124 ****
--- 156,182 ----
  	struct posix_acl	*acl_default;
  };
  
+ struct nfsd3_getxattrargs {
+ 	struct svc_fh           fh;
+ 	char *                  xattr_name;
+ 	unsigned int            xattr_name_len;
+ 	unsigned int            xattr_size_max;
+ };
+ 
+ struct nfsd3_setxattrargs {
+ 	struct svc_fh           fh;
+ 	unsigned int            xattr_flags;
+ 	char *                  xattr_name;
+ 	unsigned int            xattr_name_len;
+ 	char *                  xattr_val;
+ 	int                     xattr_val_len;
+ };
+ 
+ struct nfsd3_listxattrargs {
+ 	struct svc_fh           fh;
+ 	unsigned int            xattr_list_max;
+ };
+ 
  struct nfsd3_attrstat {
  	__be32			status;
  	struct svc_fh		fh;
***************
*** 227,232 ****
--- 285,310 ----
  	struct posix_acl	*acl_default;
  };
  
+ struct nfsd3_getxattrres {
+ 	__be32                  status;
+ 	struct svc_fh           fh;
+ 	char *                  xattr_val;
+ 	unsigned int            xattr_val_len;
+ 	unsigned int            xattr_size_max; //yxu
+ };
+ 
+ struct nfsd3_setxattrres {
+ 	__be32                  status;
+ 	struct svc_fh           fh;
+ };
+ 
+ struct nfsd3_listxattrres {
+ 	__be32                  status;
+ 	struct svc_fh           fh;
+ 	char *                  xattr_list;
+ 	unsigned int            xattr_list_len;
+ };
+ 
  /* dummy type for release */
  struct nfsd3_fhandle_pair {
  	__u32			dummy;
***************
*** 247,252 ****
--- 325,333 ----
  	struct nfsd3_linkargs		linkargs;
  	struct nfsd3_symlinkargs	symlinkargs;
  	struct nfsd3_readdirargs	readdirargs;
+ 	struct nfsd3_getxattrargs	getxattrargs;
+ 	struct nfsd3_setxattrargs	setxattrargs;
+ 	struct nfsd3_listxattrargs	listxattrargs;
  	struct nfsd3_diropres 		diropres;
  	struct nfsd3_accessres		accessres;
  	struct nfsd3_readlinkres	readlinkres;
***************
*** 260,265 ****
--- 341,349 ----
  	struct nfsd3_pathconfres	pathconfres;
  	struct nfsd3_commitres		commitres;
  	struct nfsd3_getaclres		getaclres;
+ 	struct nfsd3_getxattrres	getxattrres;
+ 	struct nfsd3_setxattrres	setxattrres;
+ 	struct nfsd3_listxattrres	listxattrres;
  };
  
  #define NFS3_SVC_XDRSIZE		sizeof(union nfsd3_xdrstore)
diff -crN orig/linux-3.5.4/fs/open.c linux-3.5.4/fs/open.c
*** orig/linux-3.5.4/fs/open.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/open.c	2014-01-20 15:45:10.353335931 -0600
***************
*** 31,36 ****
--- 31,43 ----
  #include <linux/ima.h>
  #include <linux/dnotify.h>
  
+ #ifdef CONFIG_SECURITY_DCAC
+ #include <linux/fdtable.h>
+ #include "../security/dcac/include/dcac.h"
+ #include "../security/dcac/include/file.h"
+ #include "../security/dcac/include/context.h"
+ #endif
+ 
  #include "internal.h"
  
  int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,
***************
*** 1029,1039 ****
  	if (!IS_ERR(tmp)) {
  		fd = get_unused_fd_flags(flags);
  		if (fd >= 0) {
! 			struct file *f = do_filp_open(dfd, tmp, &op, lookup);
  			if (IS_ERR(f)) {
  				put_unused_fd(fd);
  				fd = PTR_ERR(f);
  			} else {
  				fsnotify_open(f);
  				fd_install(fd, f);
  			}
--- 1036,1080 ----
  	if (!IS_ERR(tmp)) {
  		fd = get_unused_fd_flags(flags);
  		if (fd >= 0) {
!             struct file *f;
! #ifdef CONFIG_SECURITY_DCAC
!             struct path path;
!             int error;
!             struct files_struct *files = current->files;
!             struct fdtable *fdt;
! 
!             if (DCAC_FLAGS_CAN_ADD(op.open_flag)) {
!                 if (dfd < 0) {
!                     error = kern_path(tmp, 0, &path);
!                     if (error) {
!                         f = ERR_PTR(error);
!                         goto out;
!                     }
!                     f = dcac_open_attr(path.dentry, op.open_flag, fd);
!                     path_put(&path);
!                 } else {
!                     spin_lock(&files->file_lock);
!                     fdt = files_fdtable(files);
!                     if (dfd >= fdt->max_fds || !fdt->fd[dfd]) {
!                         spin_unlock(&files->file_lock);
!                         f = ERR_PTR(-EBADF);
!                         goto out;
!                     }
!                     f = dcac_add_child_attr(tmp, fdt->fd[dfd],
!                             op.open_flag, fd);
!                     spin_unlock(&files->file_lock);
!                 }
!             } else
! #endif
! 			f = do_filp_open(dfd, tmp, &op, lookup);
! out:
  			if (IS_ERR(f)) {
  				put_unused_fd(fd);
  				fd = PTR_ERR(f);
  			} else {
+ #ifdef CONFIG_SECURITY_DCAC
+                 if (!DCAC_FLAGS_CAN_ADD(flags))
+ #endif
  				fsnotify_open(f);
  				fd_install(fd, f);
  			}
***************
*** 1100,1107 ****
--- 1141,1154 ----
  		retval = filp->f_op->flush(filp, id);
  
  	if (likely(!(filp->f_mode & FMODE_PATH))) {
+ #ifdef CONFIG_SECURITY_DCAC
+         if (!DCAC_FLAGS_CAN_ADD(filp->f_flags)) {
+ #endif
  		dnotify_flush(filp, id);
  		locks_remove_posix(filp, id);
+ #ifdef CONFIG_SECURITY_DCAC
+         }
+ #endif
  	}
  	fput(filp);
  	return retval;
***************
*** 1128,1133 ****
--- 1175,1189 ----
  	filp = fdt->fd[fd];
  	if (!filp)
  		goto out_unlock;
+ 
+ #ifdef CONFIG_SECURITY_DCAC
+         if (DCAC_FLAGS_CAN_ADD(filp->f_flags)
+                 && current_dcac_task_ctx()->fixed) {
+             spin_unlock(&files->file_lock);
+             return -1;
+         }
+ #endif
+ 
  	rcu_assign_pointer(fdt->fd[fd], NULL);
  	__clear_close_on_exec(fd, fdt);
  	__put_unused_fd(files, fd);
diff -crN orig/linux-3.5.4/fs/xattr.c linux-3.5.4/fs/xattr.c
*** orig/linux-3.5.4/fs/xattr.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/fs/xattr.c	2014-01-20 15:48:09.277333673 -0600
***************
*** 46,56 ****
  	if (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||
  	    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
  		return 0;
! 
! 	/*
! 	 * The trusted.* namespace can only be accessed by privileged users.
! 	 */
! 	if (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {
  		if (!capable(CAP_SYS_ADMIN))
  			return (mask & MAY_WRITE) ? -EPERM : -ENODATA;
  		return 0;
--- 46,57 ----
  	if (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||
  	    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
  		return 0;
!  	/*
! 	 * The trusted.* and nfsd.* namespaces can only be accessed by a
! 	 * privileged user.
!  	 */
! 	if (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||
! 	    !strncmp(name, XATTR_NFSD_PREFIX, XATTR_NFSD_PREFIX_LEN)) {
  		if (!capable(CAP_SYS_ADMIN))
  			return (mask & MAY_WRITE) ? -EPERM : -ENODATA;
  		return 0;
diff -crN orig/linux-3.5.4/include/linux/nfs_fs.h linux-3.5.4/include/linux/nfs_fs.h
*** orig/linux-3.5.4/include/linux/nfs_fs.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/include/linux/nfs_fs.h	2014-01-20 15:48:09.277333673 -0600
***************
*** 62,67 ****
--- 62,68 ----
  #include <linux/nfs4.h>
  #include <linux/nfs_xdr.h>
  #include <linux/nfs_fs_sb.h>
+ #include <linux/nfs_mount.h>
  
  #include <linux/mempool.h>
  
***************
*** 318,323 ****
--- 319,329 ----
  	return NFS_SERVER(inode)->caps & cap;
  }
  
+ static inline bool nfs_server_xattrsec(struct inode *inode)
+ {
+ 	return NFS_SERVER(inode)->flags & NFS_MOUNT_XATTRSEC;
+ }
+ 
  static inline void nfs_set_verifier(struct dentry * dentry, unsigned long verf)
  {
  	dentry->d_time = verf;
***************
*** 455,476 ****
  }
  
  /*
-  * linux/fs/nfs/xattr.c
-  */
- #ifdef CONFIG_NFS_V3_ACL
- extern ssize_t nfs3_listxattr(struct dentry *, char *, size_t);
- extern ssize_t nfs3_getxattr(struct dentry *, const char *, void *, size_t);
- extern int nfs3_setxattr(struct dentry *, const char *,
- 			const void *, size_t, int);
- extern int nfs3_removexattr (struct dentry *, const char *name);
- #else
- # define nfs3_listxattr NULL
- # define nfs3_getxattr NULL
- # define nfs3_setxattr NULL
- # define nfs3_removexattr NULL
- #endif
- 
- /*
   * linux/fs/nfs/direct.c
   */
  extern ssize_t nfs_direct_IO(int, struct kiocb *, const struct iovec *, loff_t,
--- 461,466 ----
diff -crN orig/linux-3.5.4/include/linux/nfs_fs_sb.h linux-3.5.4/include/linux/nfs_fs_sb.h
*** orig/linux-3.5.4/include/linux/nfs_fs_sb.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/include/linux/nfs_fs_sb.h	2014-01-20 15:48:09.277333673 -0600
***************
*** 104,109 ****
--- 104,110 ----
  	struct list_head	master_link;	/* link in master servers list */
  	struct rpc_clnt *	client;		/* RPC client handle */
  	struct rpc_clnt *	client_acl;	/* ACL RPC client handle */
+ 	struct rpc_clnt *	client_xattr;	/* XATTR RPC client handle */
  	struct nlm_host		*nlm_host;	/* NLM client handle */
  	struct nfs_iostats __percpu *io_stats;	/* I/O statistics */
  	struct backing_dev_info	backing_dev_info;
***************
*** 194,199 ****
--- 195,201 ----
  #define NFS_CAP_MTIME		(1U << 13)
  #define NFS_CAP_POSIX_LOCK	(1U << 14)
  #define NFS_CAP_UIDGID_NOMAP	(1U << 15)
+ #define NFS_CAP_XATTR		(1U << 16)
  
  
  /* maximum number of slots to use */
diff -crN orig/linux-3.5.4/include/linux/nfs.h linux-3.5.4/include/linux/nfs.h
*** orig/linux-3.5.4/include/linux/nfs.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/include/linux/nfs.h	2014-01-20 15:48:09.277333673 -0600
***************
*** 57,62 ****
--- 57,63 ----
  	NFSERR_NOSPC = 28,		/* v2 v3 v4 */
  	NFSERR_ROFS = 30,		/* v2 v3 v4 */
  	NFSERR_MLINK = 31,		/*    v3 v4 */
+ 	NFSERR_RANGE = 34,	       /*    v3    (XATTR) */
  	NFSERR_OPNOTSUPP = 45,		/* v2 v3 */
  	NFSERR_NAMETOOLONG = 63,	/* v2 v3 v4 */
  	NFSERR_NOTEMPTY = 66,		/* v2 v3 v4 */
***************
*** 112,117 ****
--- 113,119 ----
  	NFSERR_FILE_OPEN = 10046,      /*       v4 */
  	NFSERR_ADMIN_REVOKED = 10047,  /*       v4 */
  	NFSERR_CB_PATH_DOWN = 10048,   /*       v4 */
+ 	NFSERR_NODATA = 10049,	       /*    v3    (XATTR) */
  };
  
  /* NFSv2 file types - beware, these are not the same in NFSv3 */
diff -crN orig/linux-3.5.4/include/linux/nfs_mount.h linux-3.5.4/include/linux/nfs_mount.h
*** orig/linux-3.5.4/include/linux/nfs_mount.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/include/linux/nfs_mount.h	2014-01-20 15:48:09.277333673 -0600
***************
*** 63,77 ****
  #define NFS_MOUNT_SECFLAVOUR	0x2000	/* 5 */
  #define NFS_MOUNT_NORDIRPLUS	0x4000	/* 5 */
  #define NFS_MOUNT_UNSHARED	0x8000	/* 5 */
! #define NFS_MOUNT_FLAGMASK	0xFFFF
! 
  /* The following are for internal use only */
! #define NFS_MOUNT_LOOKUP_CACHE_NONEG	0x10000
! #define NFS_MOUNT_LOOKUP_CACHE_NONE	0x20000
! #define NFS_MOUNT_NORESVPORT		0x40000
! #define NFS_MOUNT_LEGACY_INTERFACE	0x80000
  
! #define NFS_MOUNT_LOCAL_FLOCK	0x100000
! #define NFS_MOUNT_LOCAL_FCNTL	0x200000
  
  #endif
--- 63,79 ----
  #define NFS_MOUNT_SECFLAVOUR	0x2000	/* 5 */
  #define NFS_MOUNT_NORDIRPLUS	0x4000	/* 5 */
  #define NFS_MOUNT_UNSHARED	0x8000	/* 5 */
! #define NFS_MOUNT_NOXATTR	0x10000	/* 6 */
! #define NFS_MOUNT_XATTRSEC	0x20000	/* 6 */ /* utilize security xattrs */
! #define NFS_MOUNT_FLAGMASK	0x3FFFF
!  
  /* The following are for internal use only */
! #define NFS_MOUNT_LOOKUP_CACHE_NONEG	0x100000
! #define NFS_MOUNT_LOOKUP_CACHE_NONE	0x200000
! #define NFS_MOUNT_NORESVPORT		0x400000
! #define NFS_MOUNT_LEGACY_INTERFACE	0x800000
  
! #define NFS_MOUNT_LOCAL_FLOCK	0x1000000
! #define NFS_MOUNT_LOCAL_FCNTL	0x2000000
  
  #endif
diff -crN orig/linux-3.5.4/include/linux/nfs_xattr.h linux-3.5.4/include/linux/nfs_xattr.h
*** orig/linux-3.5.4/include/linux/nfs_xattr.h	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/include/linux/nfs_xattr.h	2014-01-20 15:48:09.277333673 -0600
***************
*** 0 ****
--- 1,21 ----
+ /*
+  * Extended attribute protocol for NFSv3 (XATTR)
+  *
+  *
+  * Copyright (C) 2009 Red Hat, Inc., James Morris <jmorris@redhat.com>
+  *
+  */
+ #ifndef __LINUX_NFS_XATTR_H
+ #define __LINUX_NFS_XATTR_H
+ 
+ #include <linux/xattr.h>
+ 
+ #define NFS_XATTR_PROGRAM	391063	/* TODO: find another value */
+ 
+ /* xattr procedure numbers */
+ #define XATTRPROC3_GETXATTR	1
+ #define XATTRPROC3_SETXATTR	2
+ #define XATTRPROC3_LISTXATTR	3
+ #define XATTRPROC3_RMXATTR	4
+ 
+ #endif  /* __LINUX_NFS_XATTR_H */
diff -crN orig/linux-3.5.4/include/linux/nfs_xdr.h linux-3.5.4/include/linux/nfs_xdr.h
*** orig/linux-3.5.4/include/linux/nfs_xdr.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/include/linux/nfs_xdr.h	2014-04-11 00:52:39.567623699 -0500
***************
*** 2,9 ****
--- 2,14 ----
  #define _LINUX_NFS_XDR_H
  
  #include <linux/nfsacl.h>
+ #include <linux/nfs_xattr.h>
  #include <linux/sunrpc/gss_api.h>
  
+ #ifdef CONFIG_SECURITY_DCAC
+ #include "../../security/dcac/include/hash.h"
+ #endif
+ 
  /*
   * To change the maximum rsize and wsize supported by the NFS client, adjust
   * NFS_MAX_FILE_IO_SIZE.  64KB is a typical maximum, but some servers can
***************
*** 552,557 ****
--- 557,566 ----
  	const struct nfs_fh	*fh;
  	struct qstr		name;
  	struct nfs4_sequence_args	seq_args;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t hash;
+   int by_acl;
+ #endif
  };
  
  struct nfs_removeres {
***************
*** 570,575 ****
--- 579,590 ----
  	const struct qstr		*old_name;
  	const struct qstr		*new_name;
  	struct nfs4_sequence_args	seq_args;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t old_hash;
+   dcac_hash_t new_hash;
+   int old_by_acl;
+   int new_by_acl;
+ #endif
  };
  
  struct nfs_renameres {
***************
*** 702,707 ****
--- 717,743 ----
  	struct page **		pages;
  };
  
+ struct nfs3_getxattrargs {
+ 	struct nfs_fh *		fh;
+ 	const char *		xattr_namespace;
+ 	const char *		xattr_name;
+ 	unsigned int		xattr_size_max;
+ };
+ 
+ struct nfs3_setxattrargs {
+ 	struct nfs_fh *		fh;
+ 	unsigned int		xattr_flags;
+ 	const char *		xattr_namespace;
+ 	const char *		xattr_name;
+ 	const char *		xattr_val;
+ 	int			xattr_val_len;
+ };
+ 
+ struct nfs3_listxattrargs {
+ 	struct nfs_fh *		fh;
+ 	unsigned int		xattr_list_max;
+ };
+ 
  struct nfs_diropok {
  	struct nfs_fh *		fh;
  	struct nfs_fattr *	fattr;
***************
*** 725,730 ****
--- 761,770 ----
  	struct nfs_fh *		fh;
  	const char *		name;
  	unsigned int		len;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t hash;
+   int by_acl;
+ #endif
  };
  
  struct nfs3_accessargs {
***************
*** 736,741 ****
--- 776,785 ----
  	struct nfs_fh *		fh;
  	const char *		name;
  	unsigned int		len;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t hash;
+   int by_acl;
+ #endif
  	struct iattr *		sattr;
  	enum nfs3_createmode	createmode;
  	__be32			verifier[2];
***************
*** 745,750 ****
--- 789,798 ----
  	struct nfs_fh *		fh;
  	const char *		name;
  	unsigned int		len;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t hash;
+   int by_acl;
+ #endif
  	struct iattr *		sattr;
  };
  
***************
*** 755,760 ****
--- 803,812 ----
  	struct page **		pages;
  	unsigned int		pathlen;
  	struct iattr *		sattr;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t hash;
+   int by_acl;
+ #endif
  };
  
  struct nfs3_mknodargs {
***************
*** 764,769 ****
--- 816,825 ----
  	enum nfs3_ftype		type;
  	struct iattr *		sattr;
  	dev_t			rdev;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t hash;
+   int by_acl;
+ #endif
  };
  
  struct nfs3_linkargs {
***************
*** 771,776 ****
--- 827,836 ----
  	struct nfs_fh *		tofh;
  	const char *		toname;
  	unsigned int		tolen;
+ #ifdef CONFIG_SECURITY_DCAC
+   dcac_hash_t hash;
+   int by_acl;
+ #endif
  };
  
  struct nfs3_readdirargs {
***************
*** 820,825 ****
--- 880,905 ----
  	struct posix_acl *	acl_default;
  };
  
+ struct nfs3_getxattrres {
+ 	struct nfs_fattr *	fattr;
+ 	char *			xattr_val;
+ 	int			xattr_val_len;
+ };
+ 
+ /*
+  * Note: if we don't add any more fields, we can get rid of this struct and
+  * just use fattr in the calling code.
+  */
+ struct nfs3_setxattrres {
+ 	struct nfs_fattr *	fattr;
+ };
+ 
+ struct nfs3_listxattrres {
+ 	struct nfs_fattr *	fattr;
+ 	char *			xattr_list;
+ 	int			xattr_list_len;
+ };
+ 
  #ifdef CONFIG_NFS_V4
  
  typedef u64 clientid4;
***************
*** 1443,1446 ****
--- 1523,1529 ----
  extern const struct rpc_version nfsacl_version3;
  extern const struct rpc_program nfsacl_program;
  
+ extern struct rpc_version	nfs_xattr_version3;
+ extern struct rpc_program	nfs_xattr_program;
+ 
  #endif
diff -crN orig/linux-3.5.4/include/linux/sunrpc/svc.h linux-3.5.4/include/linux/sunrpc/svc.h
*** orig/linux-3.5.4/include/linux/sunrpc/svc.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/include/linux/sunrpc/svc.h	2014-01-20 15:48:09.281333672 -0600
***************
*** 385,391 ****
  	u32			vs_xdrsize;	/* xdrsize needed for this version */
  
  	unsigned int		vs_hidden : 1;	/* Don't register with portmapper.
! 						 * Only used for nfsacl so far. */
  
  	/* Override dispatch function (e.g. when caching replies).
  	 * A return value of 0 means drop the request. 
--- 385,391 ----
  	u32			vs_xdrsize;	/* xdrsize needed for this version */
  
  	unsigned int		vs_hidden : 1;	/* Don't register with portmapper.
! 						 * Used for nfsacl and nfsxattr. */
  
  	/* Override dispatch function (e.g. when caching replies).
  	 * A return value of 0 means drop the request. 
diff -crN orig/linux-3.5.4/include/linux/syscalls.h linux-3.5.4/include/linux/syscalls.h
*** orig/linux-3.5.4/include/linux/syscalls.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/include/linux/syscalls.h	2014-04-13 14:15:25.388705338 -0500
***************
*** 860,863 ****
--- 860,874 ----
  
  asmlinkage long sys_kcmp(pid_t pid1, pid_t pid2, int type,
  			 unsigned long idx1, unsigned long idx2);
+ 
+ #ifdef CONFIG_SECURITY_DCAC
+ asmlinkage long sys_dcac_add_ops(int optype, int gid,
+         const char __user *attr, int flags);
+ asmlinkage long sys_dcac_acl_ops(int optype, int afd, int ffd,
+         const char __user *acl1, const char __user *acl2);
+ asmlinkage long sys_dcac_mask_ops(int optype, int mask);
+ asmlinkage long sys_dcac_info_ops(int optype, int fd,
+         const char __user *attr, void __user * buf, int buflen);
+ #endif
+ 
  #endif
diff -crN orig/linux-3.5.4/include/linux/xattr.h linux-3.5.4/include/linux/xattr.h
*** orig/linux-3.5.4/include/linux/xattr.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/include/linux/xattr.h	2014-01-20 15:48:09.281333672 -0600
***************
*** 61,66 ****
--- 61,69 ----
  
  #include <linux/types.h>
  
+ #define XATTR_NFSD_PREFIX "nfsd."
+ #define XATTR_NFSD_PREFIX_LEN (sizeof (XATTR_NFSD_PREFIX) - 1)
+ 
  struct inode;
  struct dentry;
  
diff -crN orig/linux-3.5.4/README linux-3.5.4/README
*** orig/linux-3.5.4/README	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/README	2012-10-15 14:47:39.505033189 -0500
***************
*** 4,10 ****
  as they tell you what this is all about, explain how to install the
  kernel, and what to do if something goes wrong. 
  
! WHAT IS LINUX?
  
    Linux is a clone of the operating system Unix, written from scratch by
    Linus Torvalds with assistance from a loosely-knit team of hackers across
--- 4,10 ----
  as they tell you what this is all about, explain how to install the
  kernel, and what to do if something goes wrong. 
  
! WHAT IS LINUX? 
  
    Linux is a clone of the operating system Unix, written from scratch by
    Linus Torvalds with assistance from a loosely-knit team of hackers across
diff -crN orig/linux-3.5.4/security/dcac/acl.c linux-3.5.4/security/dcac/acl.c
*** orig/linux-3.5.4/security/dcac/acl.c	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/acl.c	2014-04-10 22:29:52.299891938 -0500
***************
*** 0 ****
--- 1,118 ----
+ #include <linux/module.h>
+ #include <linux/types.h>
+ 
+ #include "include/acl.h"
+ #include "include/context.h"
+ 
+ static int __find_attr_in_array(const char *attr, int len,
+         uint16_t *loc, const char *buf, int n)
+ {
+     int i = 0, cmp;
+     for (; i < n; i++) {
+         if (len != strlen(buf + loc[i]))
+             cmp = 1;
+         else
+             cmp = strncmp(attr, buf + loc[i], len);
+         if (cmp == 0)
+                 return i;
+     }
+     return -1;
+ }
+ 
+ int dcac_encode_acl(char *buf, const char *text)
+ {
+     int i = 0, j = 0, p = 0, q = 0, n = 0;
+     int offset;
+     int len = strlen(text);
+     /* locations of the attributes */
+     uint16_t loc[DCAC_ACL_MAX_NUM_OF_ATTRS];
+     char dnf[128];
+ 
+     if (len <= 0)
+         return 0;
+ 
+     while (i < len) {
+         if (text[i] == '&') {
+             i++;
+             continue;
+         }
+         if (text[i] == '|') {
+             i++;
+             dnf[q++] = '|';
+             continue;
+         }
+         j = i + 1;
+         while (text[j] != '|' && text[j] != '&' && j < len)
+             j++;
+         p = __find_attr_in_array(text + i, j - i, loc, buf, n);
+         if (p < 0) {
+             if (n ==0)
+                 loc[0] = 0;
+             else
+                 loc[n] = loc[n - 1] + strlen(buf + loc[n - 1]) + 1;
+             memcpy(buf + loc[n], text + i, j - i);
+             buf[loc[n] + j - i] = 0;
+             p = n;
+             n++;
+         }
+         dnf[q++] = p;
+         i = j;
+     }
+ 
+     p = loc[n - 1] + strlen(buf + loc[n - 1]) + 1;
+     offset = (n + 1) * sizeof(uint16_t);
+     for (i = 0; i < n; i++) {
+         loc[i] += offset;
+     }
+     memmove(buf + offset, buf, p);
+     p += offset;
+     *(uint16_t *)buf = p;
+ 
+     memcpy(buf + sizeof(uint16_t), loc, offset - sizeof(uint16_t));
+ 
+     memcpy(buf + p, dnf, q);
+     return p + q;
+ }
+ EXPORT_SYMBOL_GPL(dcac_encode_acl);
+ 
+ /* acl should be in the encoded format.*/
+ int dcac_check_acl(dcac_task_ctx_t *ctx, const char *acl, int len)
+ {
+     int dnflen;
+     const unsigned char *dnf;
+     bool result = true;
+     int i = 0, j = 0;
+     uint16_t *loc;
+ 
+     if (len <= 0 || acl == NULL)
+         return -EACCES;
+     dnf = *(uint16_t *)acl + acl;
+     loc = (uint16_t *)acl + 1;
+ 
+     dnflen = len - *(uint16_t *)acl;
+ 
+     if (dnflen <= 0)
+         return -EACCES;
+ 
+     while (i < dnflen) {
+         if (dnf[i] == '|') {
+             if (j > 0 && result)
+                 return 0;
+             result = true;
+             j = 0;
+             i++;
+             continue;
+         }
+         j++;
+         if (result && !dcac_has_attr_plain(ctx, acl + loc[dnf[i]],
+                     strlen(acl + loc[dnf[i]])))
+         {
+             result = false;
+         }
+         i++;
+     }
+     if (j > 0 && result)
+         return 0;
+     return -EACCES;
+ }
+ 
diff -crN orig/linux-3.5.4/security/dcac/context.c linux-3.5.4/security/dcac/context.c
*** orig/linux-3.5.4/security/dcac/context.c	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/context.c	2014-04-10 22:32:56.507886169 -0500
***************
*** 0 ****
--- 1,589 ----
+ /*
+  * DCAC security module
+  *
+  * This file contains DCAC contexts related operations.
+  */
+ 
+ #include <linux/cred.h>
+ #include <linux/file.h>
+ #include <linux/module.h>
+ #include <linux/slab.h>
+ #include <linux/sched.h>
+ #include <linux/rwlock.h>
+ #include <linux/rwlock_types.h>
+ #include <linux/types.h>
+ 
+ #include "include/acl.h"
+ #include "include/context.h"
+ #include "include/dcac.h"
+ #include "include/file.h"
+ #include "../../fs/internal.h"
+ 
+ /**
+  * current_dcac_task_ctx - return the current task context.
+  * Note: we only use real_cred here
+  */
+ dcac_task_ctx_t *current_dcac_task_ctx(void)
+ {
+ 	return (dcac_task_ctx_t *)(current->real_cred->security);
+ }
+ EXPORT_SYMBOL_GPL(current_dcac_task_ctx);
+ 
+ /* 
+  * Deallocate a dcac_attr_t->plain
+  */
+ inline void dcac_free_attr_plain(dcac_attr_t *attr)
+ {
+     if (attr->plain)
+         kfree(attr->plain);
+ }
+ 
+ #define _dcac_free_task_acl(ctx, acl)        \
+     do {                                          \
+         if ((ctx)->acl != NULL) {     \
+             kfree((ctx)->acl);        \
+         }                                   \
+     } while (0)
+ 
+ /* 
+  * Deallocate a dcac_task_ctx
+  */
+ void dcac_free_task_ctx(dcac_task_ctx_t *ctx)
+ {
+     int i = 0;
+     for (; i < ctx->n_attrs; i++) {
+         dcac_free_attr_plain(&ctx->attr_array[i]);
+     }
+     _dcac_free_task_acl(ctx, rdacl);
+     _dcac_free_task_acl(ctx, wracl);
+     _dcac_free_task_acl(ctx, exacl);
+     _dcac_free_task_acl(ctx, mdacl);
+     _dcac_free_task_acl(ctx, encacl);
+     kfree(ctx);
+ }
+ 
+ /*
+  * Allocate a dcac_task_ctx
+  */
+ dcac_task_ctx_t *dcac_alloc_task_ctx(gfp_t gfp)
+ {
+     dcac_task_ctx_t *ctx = kzalloc(sizeof(dcac_task_ctx_t), gfp);
+     if (ctx != NULL) {
+         ctx->size = DCAC_ATTR_ARRAY_SIZE;
+         ctx->n_attrs = 0;
+         ctx->mode_mask = 0xffff;
+         ctx->can_add_uname = true;
+         ctx->fixed = false;
+         rwlock_init(&ctx->ctx_lock);
+     }
+     return ctx;
+ }
+ 
+ #define _dcac_copy_task_acl(old, new, acl, len)        \
+     do {                                          \
+         if ((old)->acl != NULL && (old)->len > 0) {     \
+             if (((new)->acl = krealloc((new)->acl, (old)->len, GFP_KERNEL))) { \
+                 memcpy((new)->acl, (old)->acl, (old)->len);  \
+                 (new)->len = (old)->len;       \
+             }                                  \
+             else                              \
+             DCAC_ERROR("Not enough memory!\n");  \
+         }                                   \
+     } while (0)
+ 
+ /*
+  * Copy the dcac_task_ctx from old_ctx to new_ctx.
+  */
+ void dcac_dup_task_ctx(dcac_task_ctx_t *new_ctx,
+         const dcac_task_ctx_t *old_ctx)
+ {
+     int i;
+     char *str;
+     new_ctx->n_attrs = old_ctx->n_attrs;
+     new_ctx->size = old_ctx->size;
+     new_ctx->mode_mask = old_ctx->mode_mask;
+     new_ctx->can_add_uname = old_ctx->can_add_uname;
+     new_ctx->fixed = old_ctx->fixed;
+     for (i = 0; i < new_ctx->n_attrs; i++) {
+         new_ctx->attr_array[i] = old_ctx->attr_array[i];
+         str = kzalloc(new_ctx->attr_array[i].len + 1, GFP_KERNEL);
+         if (str == NULL) {
+             DCAC_ERROR("Not enough memory!\n");
+             return;
+         }
+         memcpy(str, old_ctx->attr_array[i].plain, old_ctx->attr_array[i].len);
+         new_ctx->attr_array[i].plain = str;
+     }
+     rwlock_init(&new_ctx->ctx_lock);
+     _dcac_copy_task_acl(old_ctx, new_ctx, rdacl, rdacllen);
+     _dcac_copy_task_acl(old_ctx, new_ctx, wracl, wracllen);
+     _dcac_copy_task_acl(old_ctx, new_ctx, exacl, exacllen);
+     _dcac_copy_task_acl(old_ctx, new_ctx, mdacl, mdacllen);
+     _dcac_copy_task_acl(old_ctx, new_ctx, encacl, encacllen);
+ }
+ 
+ /*
+  *Set ctx->mode_mask to be ctx->mode_mask & delta - to make it more restrictive.
+  */
+ void dcac_restrict_mask(dcac_task_ctx_t *ctx, umode_t delta) {
+     if (ctx->fixed)
+         return;
+     ctx->mode_mask &= delta;
+ }
+ EXPORT_SYMBOL_GPL(dcac_restrict_mask);
+ 
+ int dcac_find_attr_plain(dcac_task_ctx_t *ctx, const char *plain,
+         int len) {
+   int high = ctx->n_attrs - 1, low = 0;
+   int pos;
+   int cmp;
+ 
+   while (high >= low) {
+     pos = (high + low) >> 1;
+     cmp = strncmp(ctx->attr_array[pos].plain, plain, len);
+     if (cmp == 0 && ctx->attr_array[pos].len > len)
+       cmp = 100;
+ 
+     if (!cmp)
+       return pos;
+ 
+     if (cmp > 0)
+       high = pos - 1;
+     else
+       low = pos + 1;
+   }
+   return -1;
+ }
+ 
+ inline bool dcac_has_attr_plain(dcac_task_ctx_t *ctx, const char *plain,
+         int len) {
+   return dcac_find_attr_plain(ctx, plain, len) >= 0;
+ }
+ 
+ bool dcac_can_add(dcac_task_ctx_t *ctx, const char *attr, int mode) {
+     int len = strlen(attr);
+     int pos = len - 2;
+     int i;
+     if (mode != DCAC_ADDONLY && mode != DCAC_ADDMOD) {
+         return -EINVAL;
+     }
+     if (current->cred->uid == 0)
+         return true;
+     if(ctx->fixed)
+         return -EACCES;
+     while (pos >= 0) {
+         if (attr[pos] == '.') {
+             i = dcac_find_attr_plain(ctx, attr, pos);
+             if (i >= 0 && (
+                         ctx->attr_array[i].mode == DCAC_ADDMOD
+                         || mode == DCAC_ADDONLY)) {
+                 return true;
+             }
+         }
+         pos--;
+     }
+     return false;
+ }
+ 
+ /*
+  * Helper function: add an attribute without check permissions.
+  */
+ int __dcac_add_attr_no_check(dcac_task_ctx_t *ctx,
+         const char *attr, int fd, int mode) {
+     int pos; int i; int cmp;
+     int high = ctx->n_attrs - 1, low = 0;
+     int len = strlen(attr);
+     char *plain;
+ 
+     pos = 0;
+     if (ctx->n_attrs >= ctx->size)
+         return -ENOMEM;
+ 
+     while (high >= low) {
+         pos = (high + low) >> 1;
+ 
+         cmp = strcmp(ctx->attr_array[pos].plain, attr);
+ 
+         if (! cmp)
+             return 0; /* already existing */
+         if (cmp > 0)
+             high = pos - 1;
+         else {
+             low = pos + 1;
+             pos++;
+         }
+     }
+     /* pos : the place to insert the new attribute */
+ 
+     plain = kzalloc(len + 1, GFP_KERNEL);
+     if (plain == NULL)
+         return -ENOMEM;
+     memcpy(plain, attr, len);
+ 
+     /* pos : the place to insert the new attribute */
+     for (i = ctx->n_attrs; i > pos; i--) {
+         ctx->attr_array[i] = ctx->attr_array[i-1];
+     }
+ 
+     ctx->attr_array[pos].plain = plain;
+     ctx->attr_array[pos].len = len;
+     ctx->attr_array[pos].fd = fd;
+     ctx->attr_array[pos].mode = mode;
+     ctx->n_attrs++;
+     return 0;
+ }
+ 
+ 
+ int dcac_add_attr(dcac_task_ctx_t *ctx, const char *attr,
+         int fd, int mode) {
+     int res;
+     write_lock_bh(&ctx->ctx_lock);
+     if (!dcac_can_add(ctx, attr, mode)) {
+         res = -EACCES;
+         goto out;
+     }
+     res =  __dcac_add_attr_no_check(ctx, attr, fd, mode);
+ out:
+     write_unlock_bh(&ctx->ctx_lock);
+     return res;
+ }
+ EXPORT_SYMBOL_GPL(dcac_add_attr);
+ 
+ void dcac_drop_attr(dcac_task_ctx_t *ctx, const char *attr) {
+     int pos;
+     write_lock_bh(&ctx->ctx_lock);
+     pos = dcac_find_attr_plain(ctx, attr, strlen(attr));
+     if (pos < 0 || ctx->fixed) {
+         write_unlock_bh(&ctx->ctx_lock);
+         return;
+     }
+     for(; pos < ctx->n_attrs - 1; pos++)
+         ctx->attr_array[pos] = ctx->attr_array[pos + 1];
+     ctx->n_attrs--;
+     write_unlock_bh(&ctx->ctx_lock);
+ }
+ EXPORT_SYMBOL_GPL(dcac_drop_attr);
+ 
+ /* Get the string name of the uid. return the length. */
+ static int __dcac_get_uid_str(uid_t uid, char *buf) {
+     int len = 0, i;
+     char temp;
+     while (uid > 0) {
+         buf[len] = '0' + (uid % 10);
+         uid = uid / 10;
+         len++;
+     }
+     if (len == 0) {
+         buf[0] = '0';
+         len = 1;
+     }
+     buf[len] = 0;
+ 
+     for (i = 0; i < len / 2; i++) {
+         temp = buf[i];
+         buf[i] = buf[len - i - 1];
+         buf[len - i - 1] = temp;
+     }
+     return len;
+ }
+ 
+ /* Get the string name of the gid. return the length.*/
+ static int __dcac_get_gid_str(gid_t gid, char *buf) {
+     int len = 0, i;
+     char temp;
+     while (gid > 0) {
+         buf[len] = '0' + (gid % 10);
+         gid = gid / 10;
+         len++;
+     }
+     if (len == 0) {
+         buf[0] = '0';
+         len = 1;
+     }
+     buf[len] = 0;
+ 
+     for (i = 0; i < len / 2; i++) {
+         temp = buf[i];
+         buf[i] = buf[len - i - 1];
+         buf[len - i - 1] = temp;
+     }
+     return len;
+ }   
+ 
+ /*
+  * Add u.<uname> to the process, if its can_add_uname is true.
+  * If success, set can_add_uname to false.
+  * return the file descriptor corresponding to this attr.
+  */
+ int dcac_add_uname_attr(int flags) {
+     /* we only consider real_cred here. */
+     int fd, error;
+     struct file *filp;
+     const struct cred *cred = current->real_cred;
+     dcac_task_ctx_t *ctx = (dcac_task_ctx_t *)cred->security;
+     char *buf = kmalloc(32, GFP_KERNEL);
+ 
+     if (!buf)
+         return -ENOMEM;
+     if (!ctx->can_add_uname || ctx->fixed)
+         return -EACCES;
+     if (flags != DCAC_ADDONLY && flags != DCAC_ADDMOD) {
+         kfree(buf);
+         return -EINVAL;
+     }
+ 
+     fd = get_unused_fd_flags(flags);
+     if (fd < 0)
+         return fd;
+ 
+     buf[0] = 'u';
+     buf[1] = '.';
+     __dcac_get_uid_str(cred->uid, buf + 2);
+     write_lock_bh(&ctx->ctx_lock);
+     error = __dcac_add_attr_no_check(ctx, buf, fd, flags);
+     if (error == 0) {
+         ctx->can_add_uname = false;
+         filp = get_empty_filp();
+         filp->private_data = buf;
+         filp->f_flags = flags;
+         fd_install(fd, filp);
+     } else {
+         kfree(buf);
+         put_unused_fd(fd);
+         fd = error;
+     }
+     write_unlock_bh(&ctx->ctx_lock);
+     return fd;
+ }
+ EXPORT_SYMBOL_GPL(dcac_add_uname_attr);
+ 
+ /*
+  * Add g.<gname> to the process, if it has u.<uname> and uname is in group
+  * <gname>.
+  */
+ int dcac_add_gname_attr(gid_t gid) {
+     /* we only consider real_cred here. */
+     int fd, error, len;
+     struct file *filp;
+     const struct cred *cred = current->real_cred;
+     dcac_task_ctx_t *ctx = (dcac_task_ctx_t *)cred->security;
+     char *buf;
+ 
+     if (ctx->fixed)
+         return -EACCES;
+ 
+     buf = kmalloc(32, GFP_KERNEL);
+ 
+     if (!buf)
+         return -ENOMEM;
+ 
+     fd = get_unused_fd_flags(DCAC_ADDONLY);
+     if (fd < 0)
+         return fd;
+ 
+     len = 2 + __dcac_get_uid_str(cred->uid, buf + 2);
+     buf[0] = 'u';
+     buf[1] = '.';
+     write_lock_bh(&ctx->ctx_lock);
+     if (!dcac_has_attr_plain(ctx, buf, len) || !in_group_p(gid)) {
+         write_unlock_bh(&ctx->ctx_lock);
+         return -EACCES;
+     }
+     __dcac_get_gid_str(gid, buf + 2);
+     buf[0] = 'g';
+     buf[1] = '.';
+     error = __dcac_add_attr_no_check(ctx, buf, fd, DCAC_ADDONLY);
+     if (error == 0) {
+         filp = get_empty_filp();
+         filp->private_data = buf;
+         filp->f_flags = DCAC_ADDONLY;
+         fd_install(fd, filp);
+     } else {
+         kfree(buf);
+         put_unused_fd(fd);
+         fd = error;
+     }
+     write_unlock_bh(&ctx->ctx_lock);
+     return fd;
+ }
+ EXPORT_SYMBOL_GPL(dcac_add_gname_attr);
+ 
+ /*
+  * Add any attribute in the text form.
+  * NOTE: root can add anything.
+  */
+ int dcac_add_any_attr(const char *attr, int flags) {
+     int error, fd;
+     struct file *f;
+     char *buf;
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+ 
+     if (flags != DCAC_ADDONLY && flags != DCAC_ADDMOD) {
+         return -EINVAL;
+     }
+ 
+     write_lock_bh(&ctx->ctx_lock);
+     if (!dcac_can_add(ctx, attr, flags)) {
+         write_unlock_bh(&ctx->ctx_lock);
+         return -EACCES;
+     }
+     fd = get_unused_fd_flags(flags);
+     if (fd < 0) {
+         write_unlock_bh(&ctx->ctx_lock);
+         return fd;
+     }
+ 
+     buf = kmalloc(strlen(attr) + 1, GFP_KERNEL);
+     if (!buf)
+         error = -ENOMEM;
+     else
+         error = __dcac_add_attr_no_check(ctx, attr, fd, flags);
+     if (error == 0) {
+         f = get_empty_filp();
+         f->f_flags = flags;
+         f->private_data = buf;
+         strcpy(buf, attr);
+         fd_install(fd, f);
+     } else {
+         if (buf)
+             kfree(buf);
+         put_unused_fd(fd);
+         fd = error;
+     }
+     write_unlock_bh(&ctx->ctx_lock);
+     return fd;
+ }
+ 
+ /*
+  * Add child attribute.
+  * suffix does not include '.'
+  */
+ struct file *dcac_add_child_attr(const char *suffix,
+         struct file *parent, int flags, int fd) {
+     int error, len;
+     struct file *f;
+     char *buf;
+     dcac_task_ctx_t *ctx = (dcac_task_ctx_t *)current->real_cred->security;
+     flags &= 7;
+ 
+     if (!DCAC_FLAGS_CAN_ADD(flags)) {
+         return ERR_PTR(-EINVAL);
+     }
+ 
+     if (!DCAC_FLAGS_CAN_ADD(parent->f_flags) || !parent->private_data)
+         return ERR_PTR(-EACCES);
+ 
+     len = strlen(parent->private_data) + strlen(suffix) + 1;
+ 
+     buf = kmalloc(len + 1, GFP_KERNEL);
+     if (!buf)
+         error = -ENOMEM;
+     else {
+         buf[0] = 0;
+         strcat(buf, parent->private_data);
+         strcat(buf, ".");
+         strcat(buf, suffix);
+         error = dcac_add_attr(ctx, buf, fd, flags);
+     }
+     if (error == 0) {
+         f = get_empty_filp();
+         f->f_flags = flags;
+         f->private_data = buf;
+     } else {
+         if (buf)
+             kfree(buf);
+         f = ERR_PTR(error);
+     }
+     return f;
+ }
+ 
+ 
+ #if 0
+ /* Add an attribute on ctx, via the acl on the attribute, represented
+  * by the extended attribute in dentry. */
+ int dcac_add_via_acl(dcac_task_ctx_t *ctx, struct dentry *dentry) {
+     char buf[DCAC_MAX_ATTR_LEN];
+     if (dcac_check_add(ctx, dentry, buf))
+         return __dcac_add_attr_no_check(ctx, buf);
+ 
+     return -EACCES;
+ }
+ EXPORT_SYMBOL_GPL(dcac_add_via_acl);
+ #endif
+ 
+ 
+ #define _dcac_update_task_acl(ctx, acltype, acllen, buf, len)        \
+     do {                                          \
+         if (len == 0) { \
+             if ((ctx)->acltype) { \
+                 kfree((ctx)->acltype); \
+                 (ctx)->acltype = NULL; \
+                 (ctx)->acllen = 0; \
+             } \
+             break; \
+         } \
+         (ctx)->acltype = krealloc((ctx)->acltype, len, GFP_KERNEL); \
+         if ((ctx)->acltype) {   \
+             memcpy((ctx)->acltype, buf, len); \
+             (ctx)->acllen = len; \
+         } \
+         else { \
+             return -ENOMEM; \
+         } \
+     } while (0)
+ 
+ int dcac_set_default_rdacl(dcac_task_ctx_t *ctx, char *acl, int len)
+ {
+     if (ctx->fixed)
+         return -EACCES;
+     write_lock_bh(&ctx->ctx_lock);
+     _dcac_update_task_acl(ctx, rdacl, rdacllen, acl, len); 
+     write_unlock_bh(&ctx->ctx_lock);
+     return 0;
+ }
+ EXPORT_SYMBOL_GPL(dcac_set_default_rdacl);
+ 
+ int dcac_set_default_wracl(dcac_task_ctx_t *ctx, char *acl, int len)
+ {
+     if (ctx->fixed)
+         return -EACCES;
+     write_lock_bh(&ctx->ctx_lock);
+     _dcac_update_task_acl(ctx, wracl, wracllen, acl, len); 
+     write_unlock_bh(&ctx->ctx_lock);
+     return 0;
+ }
+ EXPORT_SYMBOL_GPL(dcac_set_default_wracl);
+ 
+ int dcac_set_default_exacl(dcac_task_ctx_t *ctx, char *acl, int len)
+ {
+     if (ctx->fixed)
+         return -EACCES;
+     write_lock_bh(&ctx->ctx_lock);
+     _dcac_update_task_acl(ctx, exacl, exacllen, acl, len); 
+     write_unlock_bh(&ctx->ctx_lock);
+     return 0;
+ }
+ EXPORT_SYMBOL_GPL(dcac_set_default_exacl);
+ 
+ int dcac_set_default_mdacl(dcac_task_ctx_t *ctx, char *acl, int len)
+ {
+     if (ctx->fixed)
+         return -EACCES;
+     write_lock_bh(&ctx->ctx_lock);
+     _dcac_update_task_acl(ctx, mdacl, mdacllen, acl, len); 
+     write_unlock_bh(&ctx->ctx_lock);
+     return 0;
+ }
+ EXPORT_SYMBOL_GPL(dcac_set_default_mdacl);
+ 
+ int dcac_set_default_encacl(dcac_task_ctx_t *ctx, char *acl, int len)
+ {
+     if (ctx->fixed)
+         return -EACCES;
+     write_lock_bh(&ctx->ctx_lock);
+     _dcac_update_task_acl(ctx, encacl, encacllen, acl, len); 
+     write_unlock_bh(&ctx->ctx_lock);
+     return 0;
+ }
+ EXPORT_SYMBOL_GPL(dcac_set_default_encacl);
+ 
diff -crN orig/linux-3.5.4/security/dcac/file.c linux-3.5.4/security/dcac/file.c
*** orig/linux-3.5.4/security/dcac/file.c	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/file.c	2014-05-04 14:16:46.192787718 -0500
***************
*** 0 ****
--- 1,332 ----
+ #include <linux/dcache.h>
+ #include <linux/rwlock.h>
+ #include <linux/security.h>
+ #include <linux/slab.h>
+ #include <linux/string.h>
+ #include <linux/xattr.h>
+ #include <linux/module.h>
+ 
+ #include "include/acl.h"
+ #include "include/dcac.h"
+ #include "include/file.h"
+ #include "../../fs/internal.h"
+ 
+ int dcac_setxattr(struct dentry *dentry, struct inode *inode, const char *name,
+         const void *value, size_t size) {
+     int ret;
+     int newd = 0;
+     if (dentry == NULL && inode ==NULL) {
+         return -EINVAL;
+     }
+     if (dentry == NULL) {
+         newd = 1;
+         __iget(inode);
+         dentry = d_obtain_alias(inode);
+         if (!dentry || IS_ERR(dentry)) {
+             ret = -EINVAL;
+             goto out;
+         }
+     }
+     ret = __vfs_setxattr_noperm(dentry, name, value, size, 0);
+ 
+ out:
+     if (newd)
+         dput(dentry);
+     return ret;
+ }
+ EXPORT_SYMBOL(dcac_setxattr);
+ 
+ 
+ ssize_t dcac_getxattr(struct dentry *dentry, struct inode *inode, const char *name,
+         char *xvalue_buf, ssize_t buflen) {
+     ssize_t ret;
+     int newd = 0;
+     if (dentry == NULL && inode ==NULL) {
+         return -EINVAL;
+     }
+     if (dentry == NULL) {
+         newd = 1;
+         __iget(inode);
+         dentry = d_obtain_alias(inode);
+         if (!dentry || IS_ERR(dentry)) {
+             ret = -EINVAL;
+             goto out;
+         }
+     }
+     ret = vfs_getxattr(dentry, name, xvalue_buf, buflen);
+ 
+ out:
+     if (newd)
+         dput(dentry);
+     return ret;
+ }
+ EXPORT_SYMBOL(dcac_getxattr);
+ 
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+ inline int dcac_fill_acl_cache(struct inode *inode) {
+     int ret = 0, size;
+     dcac_inode_sec_t *isec;
+     char *xattr = NULL;
+     char *buf = NULL;
+ 
+     isec = inode->i_security;
+     if (!isec)
+         return -EACCES;
+ 
+     if (isec->stale || isec->initialized == 0) { /* stale: possibly set by nfs */
+         xattr = kmalloc(4096, GFP_NOFS);
+         if (!xattr) {
+             return -ENOMEM;
+         }
+         size = dcac_getxattr(NULL, inode, DCAC_FATTR_NAME_PM, xattr, 4096);
+         write_lock_bh(&isec->lock);
+         if (isec->stale == 0 && isec->initialized) {
+             goto out0;
+         }
+         if (isec->xattr)
+             kfree(isec->xattr);
+ 
+         if (size > 0) {
+             buf = kmalloc(size, GFP_NOFS);
+             if (!buf) {
+                 ret = -ENOMEM;
+                 goto out0;
+             }
+             memcpy(buf, xattr, size);
+         } else {
+             size = 0;
+         }
+         isec->xattr = buf;
+         isec->xattr_size = size;
+         memcpy(&isec->ctime, &inode->i_ctime, sizeof(isec->ctime));
+         isec->stale = 0;
+         isec->initialized = 1;
+ out0:
+         write_unlock_bh(&isec->lock);
+         if (xattr)
+             kfree(xattr);
+     }
+     return ret;
+ }
+ #endif
+ 
+ int dcac_check_permission_by_attr(dcac_task_ctx_t *ctx,
+         struct dentry *dentry, struct inode *inode, int mask, bool modify)
+ {
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+     dcac_inode_sec_t *isec;
+ #else
+     char *xattr = NULL;
+ #endif
+     void *p;
+     char *rdacl, *wracl, *exacl, *mdacl;
+     int rdlen, wrlen, exlen, mdlen;
+     int size, ret;
+ 
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+     if (!inode)
+         inode = dentry->d_inode;
+     isec = inode->i_security;
+     ret = dcac_fill_acl_cache(inode);
+     if (ret)
+         return ret;
+ #else
+     xattr = kmalloc(4096, GFP_NOFS);
+     if (!xattr)
+         return -ENOMEM;
+     size = dcac_getxattr(dentry, inode, DCAC_FATTR_NAME_PM, xattr, 4096);
+     if (size <= 0)
+         goto fail;
+     p = xattr;
+ #endif
+ 
+ 
+     read_lock_bh(&ctx->ctx_lock);
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+     read_lock_bh(&isec->lock);
+     p = isec->xattr;
+     size = isec->xattr_size;
+ #endif
+     p = dcac_next_acl_in_line(p, &rdacl, &rdlen, &size);
+     p = dcac_next_acl_in_line(p, &wracl, &wrlen, &size);
+     p = dcac_next_acl_in_line(p, &exacl, &exlen, &size);
+     p = dcac_next_acl_in_line(p, &mdacl, &mdlen, &size);
+ 
+     if ((mask & MAY_READ) && dcac_check_acl(ctx, rdacl, rdlen) != 0)
+         goto fail;
+     if ((mask & MAY_WRITE) && dcac_check_acl(ctx, wracl, wrlen) != 0)
+         goto fail;
+     if ((mask & MAY_EXEC) && dcac_check_acl(ctx, exacl, exlen) != 0)
+         goto fail;
+ 
+     if (modify && dcac_check_acl(ctx, mdacl, mdlen) != 0)
+         goto fail;
+ 
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+     read_unlock_bh(&isec->lock);
+ #else
+     kfree(xattr);
+ #endif
+     read_unlock_bh(&ctx->ctx_lock);
+     return 0;
+ 
+ fail:
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+     read_unlock_bh(&isec->lock);
+ #else
+     if (xattr)
+         kfree(xattr);
+ #endif
+     read_unlock_bh(&ctx->ctx_lock);
+     return -EACCES;
+ }
+ 
+ struct file *dcac_open_attr(struct dentry *dentry, int open_flags, int fd)
+ {
+     char *xattr = NULL, *attr, *addacl, *modacl, *buf;
+     int xsize, attrlen, addacllen, modacllen, error;
+     void *p;
+     struct file *filp;
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+ 
+     if (ctx->fixed)
+         return ERR_PTR(-EACCES);
+ 
+     xattr = kmalloc(4096, GFP_NOFS);
+     if (!xattr)
+         return ERR_PTR(-ENOMEM);
+ 
+ 
+     write_lock_bh(&ctx->ctx_lock);
+     xsize = vfs_getxattr(dentry, DCAC_FATTR_NAME_AT, xattr, 4096);
+ 
+     if (xsize <= 0) {
+         error = -EACCES;
+         goto fail;
+     }
+ 
+     p = xattr;
+     p = dcac_next_acl_in_line(p, &attr, &attrlen, &xsize);
+     p = dcac_next_acl_in_line(p, &addacl, &addacllen, &xsize);
+     p = dcac_next_acl_in_line(p, &modacl, &modacllen, &xsize);
+ 
+     if ((!DCAC_FLAGS_CAN_ADD(open_flags) ||
+             dcac_check_acl(ctx, addacl, addacllen) == 0) &&
+             (!DCAC_FLAGS_CAN_MOD(open_flags) ||
+              dcac_check_acl(ctx, modacl, modacllen) == 0)) {
+         buf = kmalloc(attrlen + 1, GFP_NOFS);
+         memcpy(buf, attr, attrlen);
+         buf[attrlen] = 0;
+         error = __dcac_add_attr_no_check(ctx, buf, fd, open_flags);
+         if (error) {
+             kfree(buf);
+             goto fail;
+         }
+ 
+         filp = get_empty_filp();
+         filp->f_flags = open_flags;
+         filp->private_data = buf;
+ 
+         kfree(xattr);
+         write_unlock_bh(&ctx->ctx_lock);
+         return filp;
+     }
+     error = -EACCES;
+ 
+ fail:
+     write_unlock_bh(&ctx->ctx_lock);
+     if (xattr != NULL)
+         kfree(xattr);
+     return ERR_PTR(error);
+ }
+ 
+ int dcac_set_file_acl(dcac_task_ctx_t *ctx,
+         struct dentry *dentry, int typeindex, char *acl, int len)
+ {
+     char *xattr = NULL;
+     void *p;
+     char *rdacl, *wracl, *exacl, *mdacl;
+     int rdlen, wrlen, exlen, mdlen;
+     int xsize, size, res;
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+     struct inode *inode;
+     dcac_inode_sec_t *isec;
+ #endif
+     xattr = kmalloc(4096, GFP_NOFS);
+     if (!xattr)
+         return -ENOMEM;
+ 
+     if (typeindex > 3 || typeindex < 0)
+         return -EINVAL;
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+     inode = dentry->d_inode;
+     if ((xsize = dcac_fill_acl_cache(inode)))
+         return xsize;
+     isec = inode->i_security;
+     size = xsize = isec->xattr_size;
+     if (size > 0)
+         memcpy(xattr, isec->xattr, size);
+ #else
+     xsize = dcac_getxattr(dentry, NULL, DCAC_FATTR_NAME_PM, xattr, 4096);
+     size = xsize;
+ #endif
+     if (size <= 0) {
+         size = 4 * sizeof(uint16_t);
+         xsize = size;
+         memset(xattr, 0, size);
+     }
+ 
+     p = xattr;
+ 
+     p = dcac_next_acl_in_line(p, &rdacl, &rdlen, &size);
+     p = dcac_next_acl_in_line(p, &wracl, &wrlen, &size);
+     p = dcac_next_acl_in_line(p, &exacl, &exlen, &size);
+     p = dcac_next_acl_in_line(p, &mdacl, &mdlen, &size);
+ 
+     if (current->cred->uid != 0 &&
+             !dcac_is_my_file(dentry->d_inode) &&
+             dcac_check_acl(ctx, mdacl, mdlen) != 0)
+         goto fail;
+ 
+     if (len < 0)
+         len = 0;
+     switch(typeindex)  {
+         case 0:
+             memmove(xattr + sizeof(uint16_t) + len,
+                     wracl - sizeof(uint16_t),
+                     wrlen + exlen + mdlen + 3 * sizeof(uint16_t));
+             (*(uint16_t *)xattr) = (uint16_t)len;
+             memcpy(rdacl, acl, len);
+             xsize += (len - rdlen);
+             break;
+         case 1:
+             memmove(xattr + 2 * sizeof(uint16_t) + len + rdlen,
+                     exacl - sizeof(uint16_t),
+                     exlen + mdlen + 2 * sizeof(uint16_t));
+             (*(uint16_t *)(wracl - sizeof(uint16_t))) = (uint16_t)len;
+             memcpy(wracl, acl, len);
+             xsize += (len - wrlen);
+             break;
+         case 2:
+             memmove(xattr + 3 * sizeof(uint16_t) + len + rdlen + wrlen,
+                     mdacl - sizeof(uint16_t),
+                     mdlen + sizeof(uint16_t));
+             (*(uint16_t *)(exacl - sizeof(uint16_t))) = (uint16_t)len;
+             memcpy(exacl, acl, len);
+             xsize += (len - exlen);
+             break;
+         case 3:
+             (*(uint16_t *)(mdacl - sizeof(uint16_t))) = (uint16_t)len;
+             memcpy(mdacl, acl, len);
+             xsize += (len - mdlen);
+             break;
+     }
+     res = dcac_setxattr(dentry, NULL, DCAC_FATTR_NAME_PM, xattr, xsize);
+     kfree(xattr);
+     return res;
+ 
+ fail:
+     if (xattr)
+         kfree(xattr);
+     return -EACCES;
+ }
diff -crN orig/linux-3.5.4/security/dcac/hash.c linux-3.5.4/security/dcac/hash.c
*** orig/linux-3.5.4/security/dcac/hash.c	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/hash.c	2014-01-21 19:50:33.368059666 -0600
***************
*** 0 ****
--- 1,81 ----
+ #include <linux/crypto.h>
+ #include <linux/scatterlist.h>
+ #include <linux/slab.h>
+ #include <crypto/hash.h>
+ #include <linux/module.h>
+ 
+ #include "include/hash.h"
+ 
+ /*
+  * Calculate the hash of attr_plain, the length of which is len.
+  * It is the caller's responsibility to ensure that the size of 
+  * the output array allocated is DCAC_HASH_SZ
+  */
+ int dcac_calc_hash(const char *attr_plain, unsigned int len, dcac_hash_t* output) {
+ 
+     struct scatterlist *sg;
+ 
+     struct crypto_hash *tfm;
+     struct hash_desc desc;
+ 
+     int retval = 0;
+ 
+     sg = kmalloc(sizeof(*sg), GFP_KERNEL);
+ 	
+     if (!sg) {
+         retval = -ENOMEM;
+ 	goto err_sg;
+     }
+ 
+     sg_init_table(sg, 1);
+     sg_init_one(sg, attr_plain, len);
+ 
+     tfm = crypto_alloc_hash(DCAC_HASH_ALGO, 0, CRYPTO_ALG_ASYNC);
+ 	
+     if (IS_ERR(tfm)) {
+         retval = -ENOMEM;
+         goto err_crypto;
+     }
+ 
+     desc.tfm = tfm;
+     desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;
+ 
+     memset(output->hashval, 0, DCAC_HASH_SZ);
+ 
+     retval = crypto_hash_digest(&desc, sg, len, output->hashval);
+ 	
+     if (retval)
+         goto err_digest;
+ 
+ err_digest:
+ 	crypto_free_hash(tfm);
+ 
+ err_crypto:
+ 	kfree(sg);
+ 
+ err_sg:
+ 	return retval;
+ }
+ EXPORT_SYMBOL(dcac_calc_hash);
+ 
+ int dcac_hash_cmp(const dcac_hash_t* h1, const dcac_hash_t* h2){
+ 
+     int i;
+  
+     for(i = 0; i < DCAC_HASH_SZ; i++)
+         if(h1->hashval[i] != h2->hashval[i])
+             break;
+ 
+     if(i < DCAC_HASH_SZ)
+         return (h1->hashval[i] - h2->hashval[i]);
+     else return 0;
+ }
+ EXPORT_SYMBOL(dcac_hash_cmp);
+ 
+ void dcac_hash_cpy(dcac_hash_t* dst, dcac_hash_t* src){
+ 
+     int i;
+ 
+     for(i = 0; i < DCAC_HASH_SZ; i++)
+         dst->hashval[i] = src->hashval[i];
+ }
diff -crN orig/linux-3.5.4/security/dcac/include/acl.h linux-3.5.4/security/dcac/include/acl.h
*** orig/linux-3.5.4/security/dcac/include/acl.h	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/include/acl.h	2014-04-10 22:25:46.439899635 -0500
***************
*** 0 ****
--- 1,98 ----
+ #ifndef __DCAC_ACL_H
+ #define __DCAC_ACL_H
+ 
+ #include <linux/types.h>
+ #include "context.h"
+ 
+ 
+ #define DCAC_ACL_MAX_NUM_OF_ATTRS 32
+ #define DCAC_ACL_MAX_LEN 4096
+ 
+ /*
+  * encode plaintext format acl to the format used on files.
+  * buf: store the result.
+  * On success, return the length of encoded acl in bytes.
+  * If fail, return -1.
+  * 'text' should be a NULL-terminating string.
+  */
+ int dcac_encode_acl(char *buf, const char *text);
+ 
+ /*
+  * acl should be in the encoded format.
+  * On success, return 0.
+  */
+ int dcac_check_acl(dcac_task_ctx_t *ctx, const char *acl, int len);
+ 
+ static inline void *dcac_next_acl_in_line(void *p, char **aclp,
+         int *len, int *remlen)
+ {
+     if (*remlen < sizeof(uint16_t))
+         goto fail;
+ 
+     *len = *(uint16_t *)p;
+ 
+     *remlen -= sizeof(uint16_t);
+     if (*remlen < *len)
+         goto fail;
+ 
+     p += sizeof(uint16_t);
+     *aclp = p;
+     *remlen -= *len;
+     return p + *len;
+ 
+ fail:
+     *len = -1;
+     *aclp = NULL;
+     return p;
+ }
+ 
+ static inline int dcac_cat_4_acls(dcac_task_ctx_t *ctx,
+         char **res, size_t *reslen)
+ {
+     void *p;
+ 
+     if (ctx->encacl && ctx->encacllen > 0) {
+       *reslen = ctx->encacllen;
+       *res = kmalloc(*reslen, GFP_KERNEL);
+       if (*res == NULL) {
+         *reslen = 0;
+         return -ENOMEM;
+       }
+       memcpy(*res, ctx->encacl, *reslen);
+       return 0;
+     }
+ 
+     *reslen = 4 * sizeof(uint16_t) + ctx->rdacllen +
+         ctx->wracllen + ctx->exacllen + ctx->mdacllen;
+     *res = kmalloc(*reslen, GFP_KERNEL);
+ 
+     if (*res == NULL) {
+         *reslen = 0;
+         return -ENOMEM;
+     }
+ 
+     p = *res;
+ 
+     *(uint16_t *)p = ctx->rdacllen;
+     p += sizeof(uint16_t);
+     memcpy(p, ctx->rdacl, ctx->rdacllen);
+     p += ctx->rdacllen;
+ 
+     *(uint16_t *)p = ctx->wracllen;
+     p += sizeof(uint16_t);
+     memcpy(p, ctx->wracl, ctx->wracllen);
+     p += ctx->wracllen;
+ 
+     *(uint16_t *)p = ctx->exacllen;
+     p += sizeof(uint16_t);
+     memcpy(p, ctx->exacl, ctx->exacllen);
+     p += ctx->exacllen;
+ 
+     *(uint16_t *)p = ctx->mdacllen;
+     p += sizeof(uint16_t);
+     memcpy(p, ctx->mdacl, ctx->mdacllen);
+ 
+     return 0;
+ }
+ 
+ #endif  /*  __DCAC_ACL_H  */
diff -crN orig/linux-3.5.4/security/dcac/include/context.h linux-3.5.4/security/dcac/include/context.h
*** orig/linux-3.5.4/security/dcac/include/context.h	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/include/context.h	2014-04-10 22:28:58.439893627 -0500
***************
*** 0 ****
--- 1,176 ----
+ /*
+  * DCAC security module
+  *
+  * This file contains DCAC contexts used to associate "labels" to objects.
+  */
+ 
+ #ifndef __DCAC_CONTEXT_H
+ #define __DCAC_CONTEXT_H
+ 
+ #include <linux/cred.h>
+ #include <linux/fs.h>
+ #include <linux/slab.h>
+ #include <linux/sched.h>
+ #include <linux/rwlock.h>
+ #include <linux/rwlock_types.h>
+ #include <linux/types.h>
+ 
+ #define DCAC_ATTR_ARRAY_SIZE 32
+ #define DCAC_MAX_ATTR_LEN 255 /* max length of an attribute in plain. */
+ 
+ /*
+  * Attribute struct, containing its hash and theplain text.
+  */
+ typedef struct dcac_attr {
+     char *plain;
+     int len;
+     int fd;
+     int mode;
+ /*    dcac_attr_t *next; */
+ } dcac_attr_t;
+ 
+ 
+ #define DCAC_PMASK_OWNERSHIP (1 << 9)
+ 
+ /**
+  * struct dcac_task_ctx - primary label for tasks.
+  */
+ typedef struct dcac_task_ctx {
+     /* mode_mask
+      * When accessing a file, either the attribute check or the user/group check
+      * should be passed. To limit the ability of an untrusted process (even it
+      * is running with a normal uid), we can properly set mode_mask. In the
+      * user/group check, instead of checking inode->i_mode, we check
+      * mode_mask & inode->i_mode. Therefore, if mode_mask == 0, the process
+      * cannot pass any user/group check.
+      * This is the implementation of "trusted attributes".
+      * Initially, mode_mask can be set to be all 1's. Then, modifications can
+      * only make it more restrictive.
+      */
+     umode_t mode_mask;
+     int n_attrs;
+     int size;
+     bool can_add_uname; /* whether the process can add u.<uname> */
+     bool fixed;
+     rwlock_t ctx_lock;
+     dcac_attr_t attr_array[DCAC_ATTR_ARRAY_SIZE]; /* sorted */
+ 
+     /* default acls */
+     char *rdacl;
+     uint16_t rdacllen;
+     char *wracl;
+     uint16_t wracllen;
+     char *exacl;
+     uint16_t exacllen;
+     char *mdacl;
+     uint16_t mdacllen;
+ 
+     char *encacl;
+     uint16_t encacllen;
+ } dcac_task_ctx_t;
+ 
+ /**
+  * current_dcac_task_ctx - return the current task context.
+  */
+ dcac_task_ctx_t *current_dcac_task_ctx(void);
+ 
+ /*
+  * true if uid on the file is the current uid, and
+  * the DCAC_PMASK_OWNERSHIP bit of mode_mask is 1
+  */
+ static inline bool dcac_is_my_file(struct inode *inode)
+ {
+     if (likely(uid_eq(current_fsuid(), inode->i_uid)))
+         return (current_dcac_task_ctx()->mode_mask & 
+                 DCAC_PMASK_OWNERSHIP) != 0;
+     return false;
+ }
+ 
+ /* 
+  * Deallocate a dcac_attr_t->plain
+  */
+ inline void dcac_free_attr_plain(dcac_attr_t *attr);
+ 
+ /* 
+  * Deallocate a dcac_task_ctx
+  */
+ void dcac_free_task_ctx(dcac_task_ctx_t *ctx);
+ 
+ /*
+  * Allocate a dcac_task_ctx
+  */
+ dcac_task_ctx_t *dcac_alloc_task_ctx(gfp_t gfp);
+ 
+ /*
+  * Copy the dcac_task_ctx from old_ctx to new_ctx.
+  */
+ void dcac_dup_task_ctx(dcac_task_ctx_t *new_ctx,
+         const dcac_task_ctx_t *old_ctx);
+ 
+ /*
+  *Set ctx->mode_mask to be ctx->mode_mask & delta - to make it more restrictive.
+  */
+ void dcac_restrict_mask(dcac_task_ctx_t *ctx, umode_t delta);
+ 
+ /*
+  * Find the index of the attribute (plain) in ctx; return -1 if not found;
+  */
+ inline int dcac_find_attr_plain(dcac_task_ctx_t *ctx, const char *plain,
+         int len);
+ /*
+  * Whether ctx has the attribute (plain text)
+  */
+ inline bool dcac_has_attr_plain(dcac_task_ctx_t *ctx, const char *plain,
+         int len);
+ 
+ int __dcac_add_attr_no_check(dcac_task_ctx_t *ctx, const char *attr,
+         int fd, int mode);
+ 
+ /* whether a task can add an attribute */
+ bool dcac_can_add(dcac_task_ctx_t *ctx, const char *attr, int mode);
+ 
+ /*
+  * Add an attribute to the current task. Return 0 if success; otherwise, return
+  * error code.
+  * DCAC does not own attr, but copies attr to the ctx.
+  */
+ int dcac_add_attr(dcac_task_ctx_t *ctx, const char *attr, int fd, int mode);
+ 
+ /*
+  * Remove attr from ctx.
+  */
+ void dcac_drop_attr(dcac_task_ctx_t *ctx, const char *attr);
+ 
+ /*
+  * Add u.<uname> to the process, if its DCAC_MASK_ADD_UNAME bit
+  * in mode_mask is 1.
+  */
+ int dcac_add_uname_attr(int flags);
+ 
+ /*
+  * Add attribute in text form.
+  * Note: root can add anything.
+  */
+ int dcac_add_any_attr(const char *attr, int flags);
+ 
+ struct file *dcac_add_child_attr(const char *suffix,
+         struct file *parent, int flags, int fd);
+ 
+ /*
+  * Add g.<gname> to the process, if it has u.<uname> and uname is in group
+  * <gname>.
+  */
+ int dcac_add_gname_attr(gid_t gid);
+ 
+ /*
+  * Add an attribute on ctx, via the acl on the attribute, represented
+  * by the extended attribute in dentry.
+  */
+ int dcac_add_via_acl(dcac_task_ctx_t *ctx, struct dentry *dentry);
+ 
+ int dcac_set_default_rdacl(dcac_task_ctx_t *ctx, char *acl, int len);
+ int dcac_set_default_wracl(dcac_task_ctx_t *ctx, char *acl, int len);
+ int dcac_set_default_exacl(dcac_task_ctx_t *ctx, char *acl, int len);
+ int dcac_set_default_mdacl(dcac_task_ctx_t *ctx, char *acl, int len);
+ int dcac_set_default_encacl(dcac_task_ctx_t *ctx, char *acl, int len);
+ #endif /* __DCAC_CONTEXT_H */
diff -crN orig/linux-3.5.4/security/dcac/include/dcac.h linux-3.5.4/security/dcac/include/dcac.h
*** orig/linux-3.5.4/security/dcac/include/dcac.h	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/include/dcac.h	2014-01-20 15:45:10.353335931 -0600
***************
*** 0 ****
--- 1,60 ----
+ /*
+  * DCAC security module
+  */
+ 
+ #ifndef __DCAC_H
+ #define __DCAC_H
+ 
+ #include <linux/fs.h>
+ 
+ /* Flag indicating whether initialization completed */
+ extern int dcac_initialized __initdata;
+ 
+ void dcac_info_message(const char *str);
+ 
+ #if defined CONFIG_SECURITY_DCAC_DEBUG_MODULE || defined CONFIG_SECURITY_DCAC_DEBUG
+ #define DCAC_DEBUG(fmt, args...) \
+     do {                       \
+         if (printk_ratelimit()) \
+         printk(KERN_DEBUG "DCAC: " fmt, ##args); \
+     } while (0)
+ #else
+ #define DCAC_DEBUG(fmt, args...)
+ #endif
+ 
+ #define DCAC_ERROR(fmt, args...) \
+     do {                       \
+         if (printk_ratelimit()) \
+         printk(KERN_ERR "DCAC: " fmt, ##args); \
+     } while (0)
+ 
+ #define DCAC_ADDONLY 4
+ #define DCAC_ADDMOD  5
+ 
+ #define DCAC_FLAGS_CAN_ADD(flags) ((flags & 7) == 4 || (flags & 7) == 5)
+ #define DCAC_FLAGS_CAN_MOD(flags) ((flags & 7) == 5)
+ 
+ #define DCAC_OP_ADD_UNAME  0
+ #define DCAC_OP_ADD_GNAME  1
+ #define DCAC_OP_ADD_ANY    2
+ 
+ #define DCAC_OP_SET_DEF_RDACL  20
+ #define DCAC_OP_SET_DEF_WRACL  21
+ #define DCAC_OP_SET_DEF_EXACL  22
+ #define DCAC_OP_SET_DEF_MDACL  23
+ #define DCAC_OP_SET_ATTR_ACL   24
+ #define DCAC_OP_SET_FILE_RDACL 25
+ #define DCAC_OP_SET_FILE_WRACL 26
+ #define DCAC_OP_SET_FILE_EXACL 27
+ #define DCAC_OP_SET_FILE_MDACL 28
+ 
+ #define DCAC_OP_GET_MASK 45
+ #define DCAC_OP_SET_MASK 46
+ #define DCAC_OP_LOCKDOWN 47
+ #define DCAC_OP_UNLOCK   48
+ 
+ #define DCAC_OP_GET_ATTR_FD        60
+ #define DCAC_OP_GET_ATTR_NAME      61
+ #define DCAC_OP_GET_ATTR_FD_LIST   62
+ 
+ #endif /* __DCAC_H */
diff -crN orig/linux-3.5.4/security/dcac/include/file.h linux-3.5.4/security/dcac/include/file.h
*** orig/linux-3.5.4/security/dcac/include/file.h	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/include/file.h	2014-04-10 22:23:56.015903095 -0500
***************
*** 0 ****
--- 1,67 ----
+ #ifndef __DCAC_FILE_H
+ #define __DCAC_FILE_H
+ 
+ #include <linux/fs.h>
+ #include <linux/types.h>
+ #include <linux/rwlock.h>
+ #include <linux/rwlock_types.h>
+ #include <linux/time.h>
+ 
+ #include "context.h"
+ #include "hash.h"
+ 
+ #define DCAC_FATTR_PREFIX "security.dcac."
+ 
+ /*
+  * The values of this  are just the encoded acl.
+  * DCAC_FATTR_NAME_PM
+  * contains for acls, read, write, exec, modify
+  * Format:
+  * Concatenation of four of
+  *    uint16_t length
+  *    acl
+  */
+ #define DCAC_FATTR_NAME_PM "security.dcac.pm"
+ 
+ /*
+  * DCAC_FATTR_NAME_AT
+  * contains the ADD and MODIFY acls for an attribute
+  * value format:
+  * 1) size of the plaintext attribute (uint16_t)
+  * 2) plaintext attribute
+  * 3) size of the ADD acl (uint16_t)
+  * 4) encoded ADD acl
+  * 5) size of the MODIFY acl (uint16_t)
+  * 6) encoded MODIFY acl
+  */
+ #define DCAC_FATTR_NAME_AT "security.dcac.at"
+ 
+ int dcac_setxattr(struct dentry *dentry, struct inode *inode, const char *name,
+         const void *value, size_t size);
+ 
+ /* if *xvalue_buf is NULL or buflen is too small, reallocate the buffer. */
+ ssize_t dcac_getxattr(struct dentry *dentry, struct inode *inode, const char *name,
+         char *xvalue_buf, ssize_t buflen);
+ 
+ 
+ int dcac_check_permission_by_attr(dcac_task_ctx_t *ctx,
+         struct dentry *dentry, struct inode *inode, int mask, bool modify);
+ 
+ struct file *dcac_open_attr(struct dentry *dentry, int open_flags, int fd);
+ 
+ int dcac_set_file_acl(dcac_task_ctx_t *ctx,
+         struct dentry *dentry, int typeindex, char *acl, int len);
+ 
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+ typedef struct dcac_inode_sec {
+     int xattr_size;
+     char *xattr;
+     rwlock_t lock;
+     int initialized;
+     struct timespec ctime;
+     int stale;
+     int by_acl;  /* 0: permitted by DAC, 1: permitted by DCAC. */
+ } dcac_inode_sec_t;
+ #endif
+ 
+ #endif /* __DCAC_FILE_H */
diff -crN orig/linux-3.5.4/security/dcac/include/hash.h linux-3.5.4/security/dcac/include/hash.h
*** orig/linux-3.5.4/security/dcac/include/hash.h	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/include/hash.h	2014-01-21 18:35:38.328116396 -0600
***************
*** 0 ****
--- 1,33 ----
+ /*
+  * DCAC hash functions
+  */
+ 
+ #include <crypto/sha.h>
+ 
+ #ifndef __DCAC_HASH_H
+ #define __DCAC_HASH_H
+ 
+ 
+ #define DCAC_HASH_ALGO "sha256"
+ 
+ #define DCAC_HASH_SZ (SHA256_DIGEST_SIZE + 2)
+ 
+ typedef struct{
+   u8 hashval[DCAC_HASH_SZ];
+ }dcac_hash_t;
+ 
+ /*
+  * Calculate the hash of attr_plain, the length of which is len.
+  * It is the caller's responsibility to ensure that the size of 
+  * the output array allocated is DCAC_HASH_SZ
+  */
+ int dcac_calc_hash(const char *attr_plain, unsigned int len, dcac_hash_t* output);
+ 
+ /*
+  * Check if two hash values are equal
+  */ 
+ int dcac_hash_cmp(const dcac_hash_t* h1, const dcac_hash_t* h2);
+ 
+ void dcac_hash_cpy(dcac_hash_t* dst, dcac_hash_t* src);
+ 
+ #endif /* __DCAC_HASH_H */
diff -crN orig/linux-3.5.4/security/dcac/include/ipc.h linux-3.5.4/security/dcac/include/ipc.h
*** orig/linux-3.5.4/security/dcac/include/ipc.h	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/include/ipc.h	2014-01-20 15:45:10.353335931 -0600
***************
*** 0 ****
--- 1,13 ----
+ #ifndef __DCAC_IPC_H
+ #define __DCAC_IPC_H
+ 
+ #include <linux/types.h>
+ 
+ #include "context.h"
+ 
+ typedef struct dcac_ipc_sec {
+     int size;
+     char *xattr;
+ } dcac_ipc_sec_t;
+ 
+ #endif /* __DCAC_IPC_H */
diff -crN orig/linux-3.5.4/security/dcac/inode_perm.c linux-3.5.4/security/dcac/inode_perm.c
*** orig/linux-3.5.4/security/dcac/inode_perm.c	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/inode_perm.c	2014-01-20 15:45:10.353335931 -0600
***************
*** 0 ****
--- 1,201 ----
+ /*
+  *  yxu: Copied from linux/fs/namei.c
+  *  We can't directly use inode_permission, because it invokes the capable hook,
+  *  which always return 0 for DAC checks.
+  *  Instead, I copied the code from namei.c, and replaced the capability check
+  *  with the default cap_capable functioin.
+  */
+ 
+ #include <linux/fs.h>
+ #include <linux/namei.h>
+ #include <linux/fsnotify.h>
+ #include <linux/security.h>
+ #include <linux/audit.h>
+ #include <linux/capability.h>
+ #include <linux/file.h>
+ #include <linux/device_cgroup.h>
+ #include <linux/posix_acl.h>
+ #include <asm/uaccess.h>
+ 
+ static int check_acl(struct inode *inode, int mask)
+ {
+ #ifdef CONFIG_FS_POSIX_ACL
+ 	struct posix_acl *acl;
+ 
+ 	if (mask & MAY_NOT_BLOCK) {
+ 		acl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);
+ 	        if (!acl)
+ 	                return -EAGAIN;
+ 		/* no ->get_acl() calls in RCU mode... */
+ 		if (acl == ACL_NOT_CACHED)
+ 			return -ECHILD;
+ 	        return posix_acl_permission(inode, acl, mask & ~MAY_NOT_BLOCK);
+ 	}
+ 
+ 	acl = get_cached_acl(inode, ACL_TYPE_ACCESS);
+ 
+ 	/*
+ 	 * A filesystem can force a ACL callback by just never filling the
+ 	 * ACL cache. But normally you'd fill the cache either at inode
+ 	 * instantiation time, or on the first ->get_acl call.
+ 	 *
+ 	 * If the filesystem doesn't have a get_acl() function at all, we'll
+ 	 * just create the negative cache entry.
+ 	 */
+ 	if (acl == ACL_NOT_CACHED) {
+ 	        if (inode->i_op->get_acl) {
+ 			acl = inode->i_op->get_acl(inode, ACL_TYPE_ACCESS);
+ 			if (IS_ERR(acl))
+ 				return PTR_ERR(acl);
+ 		} else {
+ 		        set_cached_acl(inode, ACL_TYPE_ACCESS, NULL);
+ 		        return -EAGAIN;
+ 		}
+ 	}
+ 
+ 	if (acl) {
+ 	        int error = posix_acl_permission(inode, acl, mask);
+ 	        posix_acl_release(acl);
+ 	        return error;
+ 	}
+ #endif
+ 
+ 	return -EAGAIN;
+ }
+ 
+ /*
+  * This does the basic permission checking
+  */
+ static int acl_permission_check(struct inode *inode, int mask)
+ {
+ 	unsigned int mode = inode->i_mode;
+ 
+ 	if (likely(uid_eq(current_fsuid(), inode->i_uid)))
+ 		mode >>= 6;
+ 	else {
+ 		if (IS_POSIXACL(inode) && (mode & S_IRWXG)) {
+ 			int error = check_acl(inode, mask);
+ 			if (error != -EAGAIN)
+ 				return error;
+ 		}
+ 
+ 		if (in_group_p(inode->i_gid))
+ 			mode >>= 3;
+ 	}
+ 
+ 	/*
+ 	 * If the DACs are ok we don't need any capability check.
+ 	 */
+ 	if ((mask & ~mode & (MAY_READ | MAY_WRITE | MAY_EXEC)) == 0)
+ 		return 0;
+ 	return -EACCES;
+ }
+ 
+ static bool dcac_ns_capable(struct user_namespace *ns, int cap)
+ {
+     if (unlikely(!cap_valid(cap))) {
+         printk(KERN_CRIT "capable() called with invalid cap=%u\n", cap);
+         BUG();
+     }
+ 
+     if (cap_capable(current_cred(), ns, cap, SECURITY_CAP_AUDIT) == 0) {
+         current->flags |= PF_SUPERPRIV;
+         return true;
+     }
+     return false;
+ }
+ 
+ bool dcac_inode_capable(const struct inode *inode, int cap)
+ {
+     struct user_namespace *ns = current_user_ns();
+     return dcac_ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);
+ }
+ 
+ int dcac_generic_permission(struct inode *inode, int mask)
+ {
+ 	int ret;
+ 
+ 	/*
+ 	 * Do the basic permission checks.
+ 	 */
+ 	ret = acl_permission_check(inode, mask);
+ 	if (ret != -EACCES)
+ 		return ret;
+ 
+ 	if (S_ISDIR(inode->i_mode)) {
+ 		/* DACs are overridable for directories */
+ 		if (dcac_inode_capable(inode, CAP_DAC_OVERRIDE))
+ 			return 0;
+ 		if (!(mask & MAY_WRITE))
+ 			if (dcac_inode_capable(inode, CAP_DAC_READ_SEARCH))
+ 				return 0;
+ 		return -EACCES;
+ 	}
+ 	/*
+ 	 * Read/write DACs are always overridable.
+ 	 * Executable DACs are overridable when there is
+ 	 * at least one exec bit set.
+ 	 */
+ 	if (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))
+ 		if (dcac_inode_capable(inode, CAP_DAC_OVERRIDE))
+ 			return 0;
+ 
+ 	/*
+ 	 * Searching includes executable on directories, else just read.
+ 	 */
+ 	mask &= MAY_READ | MAY_WRITE | MAY_EXEC;
+ 	if (mask == MAY_READ)
+ 		if (dcac_inode_capable(inode, CAP_DAC_READ_SEARCH))
+ 			return 0;
+ 
+ 	return -EACCES;
+ }
+ 
+ static inline int do_inode_permission(struct inode *inode, int mask)
+ {
+ #if 0
+ 	if (unlikely(!(inode->i_opflags & IOP_FASTPERM))) {
+ 		if (likely(inode->i_op->permission))
+ 			return inode->i_op->permission(inode, mask);
+ 
+ 		/* This gets set once for the inode lifetime */
+ 		spin_lock(&inode->i_lock);
+ 		inode->i_opflags |= IOP_FASTPERM;
+ 		spin_unlock(&inode->i_lock);
+ 	}
+ #endif
+ 	return dcac_generic_permission(inode, mask);
+ }
+ 
+ int __dcac_inode_permission(struct inode *inode, int mask)
+ {
+ 	int retval;
+ 
+ 	if (unlikely(mask & MAY_WRITE)) {
+ 		umode_t mode = inode->i_mode;
+ 
+ 		/*
+ 		 * Nobody gets write access to a read-only fs.
+ 		 */
+ 		if (IS_RDONLY(inode) &&
+ 		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
+ 			return -EROFS;
+ 
+ 		/*
+ 		 * Nobody gets write access to an immutable file.
+ 		 */
+ 		if (IS_IMMUTABLE(inode))
+ 			return -EACCES;
+ 	}
+ 
+ 	retval = do_inode_permission(inode, mask);
+ 	if (retval)
+ 		return retval;
+ 
+ 	retval = devcgroup_inode_permission(inode, mask);
+ 	if (retval)
+ 		return retval;
+ 
+ 	return 0;
+ }
+ 
diff -crN orig/linux-3.5.4/security/dcac/Kconfig linux-3.5.4/security/dcac/Kconfig
*** orig/linux-3.5.4/security/dcac/Kconfig	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/Kconfig	2014-04-10 22:16:38.559916789 -0500
***************
*** 0 ****
--- 1,14 ----
+ config SECURITY_DCAC
+     bool "Enable DCAC"
+     depends on SECURITY
+ 	select SECURITYFS
+ 	select SECURITY_PATH
+ 
+ config SECURITY_DCAC_DEBUG
+     bool "Enable DCAC Debugging"
+     depends on SECURITY_DCAC
+ 
+ config SECURITY_DCAC_INODE_CACHE
+     bool "Cache the DCAC file xattr in struct inode"
+     default y
+     depends on SECURITY_DCAC
diff -crN orig/linux-3.5.4/security/dcac/lsm.c linux-3.5.4/security/dcac/lsm.c
*** orig/linux-3.5.4/security/dcac/lsm.c	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/lsm.c	2014-04-16 14:21:33.557303185 -0500
***************
*** 0 ****
--- 1,823 ----
+ /*
+  * DCAC security module
+  *
+  * This file contains DCAC LSM hooks.
+  */
+ 
+ #include <linux/security.h>
+ #include <linux/moduleparam.h>
+ #include <linux/mm.h>
+ #include <linux/mman.h>
+ #include <linux/module.h>
+ #include <linux/mount.h>
+ #include <linux/namei.h>
+ #include <linux/msg.h>
+ #include <linux/nsproxy.h>
+ #include <linux/ipc_namespace.h>
+ #include <linux/ptrace.h>
+ #include <linux/ctype.h>
+ #include <linux/sysctl.h>
+ #include <linux/shm.h>
+ #include <linux/audit.h>
+ #include <linux/xattr.h>
+ #include <linux/user_namespace.h>
+ #include <net/sock.h>
+ 
+ #include "include/acl.h"
+ #include "include/context.h"
+ #include "include/dcac.h"
+ #include "include/file.h"
+ #include "include/ipc.h"
+ 
+ /* Flag indicating whether initialization completed */
+ int dcac_initialized __initdata;
+ 
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+ static struct kmem_cache *dcac_inode_cache;
+ #endif
+ 
+ 
+ void dcac_info_message(const char *str)
+ {
+     printk(KERN_INFO "DCAC: %s\n", str);
+ }
+ 
+ /*
+  * LSM hook functions
+  */
+ 
+ /*
+  * free the associated dcac_task_ctx
+  */
+ static void dcac_cred_free(struct cred *cred)
+ {
+     dcac_free_task_ctx(cred->security);
+     cred->security = NULL;
+ }
+ 
+ /*
+  * allocate the dcac part of blank credentials
+  */
+ static int dcac_cred_alloc_blank(struct cred *cred, gfp_t gfp)
+ {
+     /* freed by dcac_cred_free */
+     struct dcac_task_ctx *ctx = dcac_alloc_task_ctx(gfp);
+     if (ctx == NULL)
+         return -ENOMEM;
+ 
+     cred->security = ctx;
+     return 0;
+ }
+ 
+ /*
+  * prepare new dcac_task_ctx for modification by prepare_cred block
+  */
+ static int dcac_cred_prepare(struct cred *new, const struct cred *old,
+                  gfp_t gfp)
+ {
+     /* freed by dcac_cred_free */
+     struct dcac_task_ctx *ctx = dcac_alloc_task_ctx(gfp);
+     if (ctx == NULL)
+         return -ENOMEM;
+ 
+     dcac_dup_task_ctx(ctx, old->security);
+     new->security = ctx;
+     return 0;
+ }
+ 
+ /*
+  * transfer the dcac data to a blank set of creds
+  */
+ static void dcac_cred_transfer(struct cred *new, const struct cred *old)
+ {
+     const struct dcac_task_ctx *old_ctx = old->security;
+     struct dcac_task_ctx *new_ctx = new->security;
+ 
+     dcac_dup_task_ctx(new_ctx, old_ctx);
+ }
+ 
+ static int dcac_ptrace_access_check(struct task_struct *child,
+                     unsigned int mode)
+ {
+     if (child->parent == current)
+         return 0;
+     return -EPERM;
+ }
+ 
+ static int dcac_ptrace_traceme(struct task_struct *parent)
+ {
+     if (current->parent == parent)
+         return 0;
+     return -EPERM;
+ }
+ 
+ static inline int dcac_task_kill(struct task_struct *p,
+         struct siginfo *info, int sig, u32 secid)
+ {
+     if ((current_dcac_task_ctx()->mode_mask & 
+                 DCAC_PMASK_OWNERSHIP) != 0)
+         return 0;
+ 
+     if (info == (void *)(1) || SI_FROMKERNEL(info))
+         return 0;
+ 
+     switch(sig) {
+         case SIGCHLD:
+             if (p == current->parent)
+                 return 0;
+             return -EPERM;
+         case SIGKILL:
+         case SIGSTOP:
+         case SIGCONT:
+             if (p->parent == current)
+                 return 0;
+             return -EPERM;
+     }
+     return 0;
+ }
+ 
+ static int dcac_capable(const struct cred *cred, struct user_namespace *ns,
+                 int cap, int audit)
+ {
+     if (/*cap == CAP_DAC_OVERRIDE || */cap == CAP_IPC_OWNER)
+         return 0;
+     return cap_capable(cred, ns, cap, audit);
+ }
+ static int dcac_path_chmod(struct path *path, umode_t mode)
+ {
+     if (current_dcac_task_ctx()->mode_mask & DCAC_PMASK_OWNERSHIP)
+         return 0;
+     return -EACCES;
+ }
+ 
+ extern int __dcac_inode_permission(struct inode *inode,  int mask);
+ 
+ static int dcac_inode_permission(struct inode *inode,  int mask) {
+     int mask2, ret, trial;
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+     unsigned int mode = ctx->mode_mask;
+     dcac_inode_sec_t *isec = inode->i_security;
+     trial = 0;
+ 
+ retry:
+     isec->by_acl = 0;
+     trial++;
+     /* Need to grant NFSD all permissions.. */
+     if (current_fsuid() == 0 || current_uid() == 0)
+         return 0;
+     if (likely(uid_eq(current_fsuid(), inode->i_uid)))
+         mode >>= 6;
+     else {
+         if (in_group_p(inode->i_gid))
+             mode >>= 3;
+     }
+ 
+     mask2 = 0;
+     if ((mask & ~mode & (MAY_READ)) || ((mask & MAY_READ) &&
+             __dcac_inode_permission(inode, mask & MAY_READ) != 0))
+         mask2 |= MAY_READ;
+     if ((mask & ~mode & (MAY_WRITE)) || ((mask & MAY_WRITE) &&
+             __dcac_inode_permission(inode, mask & MAY_WRITE) != 0))
+         mask2 |= MAY_WRITE;
+     if ((mask & ~mode & (MAY_EXEC)) || ((mask & MAY_EXEC) &&
+             __dcac_inode_permission(inode, mask & MAY_EXEC) != 0))
+         mask2 |= MAY_EXEC;
+ 
+     if (mask2 == 0)
+         return 0;
+ 
+     /* DCAC check */
+     isec->by_acl = 1;
+     ret = dcac_check_permission_by_attr(ctx, NULL,
+             inode, mask2, false);
+     if (ret && trial == 1) {
+         /* may force getattr on NFS for dir writes. */
+         if (likely(inode->i_op->permission))
+             inode->i_op->permission(inode, mask);
+         goto retry;
+     }
+     return ret;
+ }
+ 
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+ static int dcac_inode_alloc_security(struct inode* inode)
+ {
+     dcac_inode_sec_t *isec =
+         kmem_cache_zalloc(dcac_inode_cache, GFP_NOFS);
+     if (!isec)
+         return -ENOMEM;
+     rwlock_init(&isec->lock);
+ 
+     inode->i_security = isec;
+     return 0;
+ }
+ 
+ static void dcac_inode_free_security(struct inode* inode)
+ {
+     dcac_inode_sec_t *isec = inode->i_security;
+     if (isec->xattr)
+         kfree(isec->xattr);
+     kmem_cache_free(dcac_inode_cache, isec);
+     inode->i_security = NULL;
+ }
+ 
+ static int dcac_inode_setsecurity(struct inode *inode, const char *name,
+ 				     const void *value, size_t size, int flags) {
+     dcac_inode_sec_t *isec = inode->i_security;
+     char *buf = NULL;
+     
+     if (strcmp(name, DCAC_FATTR_NAME_PM + XATTR_SECURITY_PREFIX_LEN))
+         return -EOPNOTSUPP;
+     write_lock_bh(&isec->lock);
+     if (isec->xattr)
+         kfree(isec->xattr);
+ 
+     if (size > 0) {
+         buf = kmalloc(size, GFP_NOFS);
+         if (!buf) {
+             write_unlock_bh(&isec->lock);
+             return -ENOMEM;
+         }
+         memcpy(buf, value, size);
+     } else {
+         size = 0;
+     }
+ 
+     isec->xattr = buf;
+     isec->xattr_size = size;
+     memcpy(&isec->ctime, &inode->i_ctime, sizeof(isec->ctime));
+     isec->initialized = 1;
+     isec->stale = 0;
+     write_unlock_bh(&isec->lock);
+     return 0;
+ }
+ 
+ static void dcac_inode_post_setxattr(struct dentry *dentry, const char *name,
+ 					const void *value, size_t size, int flags) {
+     dcac_inode_sec_t *isec = dentry->d_inode->i_security;
+     char *buf = NULL;
+     
+     if (strcmp(name, DCAC_FATTR_NAME_PM))
+         return;
+ 
+     write_lock_bh(&isec->lock);
+     if (isec->xattr)
+         kfree(isec->xattr);
+ 
+     if (size > 0) {
+         buf = kmalloc(size, GFP_NOFS);
+         /* not sure how to handle ENOMEM */
+         memcpy(buf, value, size);
+     } else {
+         size = 0;
+     }
+ 
+     isec->xattr = buf;
+     isec->xattr_size = size;
+     memcpy(&isec->ctime, &dentry->d_inode->i_ctime, sizeof(isec->ctime));
+     isec->initialized = 1;
+     isec->stale = 0;
+     write_unlock_bh(&isec->lock);
+ }
+ 
+ static int dcac_inode_notifysecctx(struct inode *inode, void *ctx, u32 ctxlen)
+ {
+     return dcac_inode_setsecurity(inode,
+             DCAC_FATTR_NAME_PM + XATTR_SECURITY_PREFIX_LEN, ctx, ctxlen, 0);
+ }
+ 
+ static void dcac_d_instantiate(struct dentry *dentry, struct inode *inode)
+ {
+ #if 0  /* yxu : not do anything here: delayed until we actully need the ACL. */
+     char *xbuf = NULL, *buf = NULL;
+     int xsize = 0;
+     dcac_inode_sec_t *isec;
+     if (!inode || !inode->i_op || !inode->i_op->getxattr)
+         return;
+     isec = inode->i_security;
+     if (isec->initialized)
+         return;
+ 
+     write_lock(&isec->lock);
+     if (isec->initialized)
+         goto out;
+ 
+     xbuf = kmalloc(4096, GFP_NOFS);
+     if (!xbuf) {
+         goto out;
+     }
+     xsize = inode->i_op->getxattr(dentry, DCAC_FATTR_NAME_PM, xbuf, 4096);
+ 
+     if (xsize > 0) {
+         buf = kmalloc(xsize, GFP_NOFS);
+         if (!buf) {
+             goto out;
+         }
+         memcpy(buf, xbuf, xsize);
+     } else
+         xsize = 0;
+ 
+     isec->xattr = buf;
+     isec->xattr_size = xsize;
+     memcpy(&isec->ctime, &inode->i_ctime, sizeof(isec->ctime));
+     isec->initialized = 1;
+ 
+ out:
+     write_unlock(&isec->lock);
+     if (xbuf)
+         kfree(xbuf);
+     return;
+ #endif
+ }
+ 
+ #else
+ static int dcac_inode_alloc_security(struct inode* inode)
+ {
+     return 0;
+ }
+ 
+ static void dcac_inode_free_security(struct inode* inode)
+ {
+ }
+ #endif
+ 
+ static int dcac_inode_setxattr(struct dentry *dentry, const char *name,
+         const void *value, size_t size, int flags)
+ {
+     int ret;
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+ 
+     ret = cap_inode_setxattr(dentry, name, value, size, flags);
+     if (ret == 0)
+         return 0;
+     if (strcmp(name, DCAC_FATTR_NAME_AT) == 0)
+         return -EACCES;
+     if (strncmp(name, DCAC_FATTR_PREFIX, sizeof(DCAC_FATTR_PREFIX) - 1) == 0)
+     {
+         if (dcac_is_my_file(dentry->d_inode))
+             return 0;
+         return dcac_check_permission_by_attr(ctx, dentry, NULL, 0, true);
+     }
+     return ret;
+ }
+ 
+ static int dcac_inode_removexattr(struct dentry *dentry, const char *name)
+ {
+     int ret;
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+ 
+     ret = cap_inode_removexattr(dentry, name);
+     if (ret == 0)
+         return 0;
+     if (strcmp(name, DCAC_FATTR_NAME_AT) == 0)
+         return -EACCES;
+     if (strncmp(name, DCAC_FATTR_PREFIX, sizeof(DCAC_FATTR_PREFIX) - 1) == 0)
+     {
+         if (dcac_is_my_file(dentry->d_inode))
+             return 0;
+         return dcac_check_permission_by_attr(ctx, dentry, NULL, 0, true);
+     }
+     return ret;
+ }
+ 
+ static int dcac_inode_init_security(struct inode *inode, struct inode *dir,
+         const struct qstr *qstr, char **name,
+         void **value, size_t *len){
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+     char *xattr;
+     size_t xlen;
+ 
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+     char *iattr;
+     size_t ilen;
+     dcac_inode_sec_t *isec = inode->i_security;
+ #endif
+ 
+     if (ctx->rdacl || ctx->wracl || ctx->exacl || ctx->mdacl || ctx->encacl) {
+         if (dcac_cat_4_acls(ctx, &xattr, &xlen) != 0)
+             return -ENOMEM;
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+         if (dcac_cat_4_acls(ctx, &iattr, &ilen) != 0) {
+             kfree(xattr);
+             return -ENOMEM;
+         }
+         isec->xattr = iattr;
+         isec->xattr_size = ilen;
+         isec->initialized = 1;
+         isec->stale = 0;
+ #endif
+         *value = xattr;
+         *len = xlen;
+         *name = kmalloc(sizeof(DCAC_FATTR_NAME_PM) - XATTR_SECURITY_PREFIX_LEN,
+                 GFP_KERNEL);
+         strcpy(*name, DCAC_FATTR_NAME_PM + XATTR_SECURITY_PREFIX_LEN);
+         return 0;
+     }
+ 
+     return -EOPNOTSUPP;
+ }
+ 
+ int dcac_inode_setsecctx(struct dentry *dentry, void *ctx, u32 ctxlen)
+ {
+     return __vfs_setxattr_noperm(dentry, DCAC_FATTR_NAME_PM, ctx, ctxlen, 0);
+ }
+ 
+ static bool dcac_cap_ns_capable(struct user_namespace *ns, int cap)
+ {
+     if (cap_capable(current_cred(), ns, cap, SECURITY_CAP_AUDIT) == 0) {
+         current->flags |= PF_SUPERPRIV;
+         return true;
+     }
+     return false;
+ }
+ 
+ static int dcac_ipc_permission(struct kern_ipc_perm *ipcp, short flag)
+ {
+     uid_t euid = current_euid();
+     int requested_mode, granted_mode;
+     int mask;
+     void *p;
+     char *rdacl, *wracl, *exacl;
+     int rdlen, wrlen, exlen;
+     int size, ret;
+     struct ipc_namespace *ns = current->nsproxy->ipc_ns;
+ 	dcac_ipc_sec_t *isec = ipcp->security;
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+ 
+     /*
+      * Need to do UID/GID check, since we always grant CAP_IPC_OWNER
+      * capability
+      */
+     requested_mode = (flag >> 6) | (flag >> 3) | flag;
+     granted_mode = ipcp->mode & ctx->mode_mask;
+     if (euid == ipcp->cuid ||
+             euid == ipcp->uid)
+         granted_mode >>= 6;
+     else if (in_group_p(ipcp->cgid) || in_group_p(ipcp->gid))
+         granted_mode >>= 3;
+     mask = (requested_mode & ~granted_mode & 0007);
+     if (mask == 0 || dcac_cap_ns_capable(ns->user_ns, CAP_IPC_OWNER))
+         return 0;
+ 
+     p = isec->xattr;
+     size = isec->size;
+     p = dcac_next_acl_in_line(p, &rdacl, &rdlen, &size);
+     p = dcac_next_acl_in_line(p, &wracl, &wrlen, &size);
+     p = dcac_next_acl_in_line(p, &exacl, &exlen, &size);
+ 
+     read_lock_bh(&ctx->ctx_lock);
+     ret = -EACCES;
+     if ((mask & MAY_READ) && dcac_check_acl(ctx, rdacl, rdlen) != 0)
+         goto out;
+     if ((mask & MAY_WRITE) && dcac_check_acl(ctx, wracl, wrlen) != 0)
+         goto out;
+     if ((mask & MAY_EXEC) && dcac_check_acl(ctx, exacl, exlen) != 0)
+         goto out;
+ 
+     ret = 0;
+ out:
+     read_unlock_bh(&ctx->ctx_lock);
+     return ret;
+ }
+ 
+ 
+ static int ipc_alloc_security(dcac_task_ctx_t *ctx,
+ 			      struct kern_ipc_perm *perm)
+ {
+ 	dcac_ipc_sec_t *isec;
+     char *xattr = NULL;
+     size_t xlen = 0;
+ 
+ 	isec = kzalloc(sizeof(dcac_ipc_sec_t), GFP_KERNEL);
+ 	if (!isec)
+ 		return -ENOMEM;
+     if (ctx->rdacl || ctx->wracl || ctx->exacl || ctx->mdacl) {
+         if (dcac_cat_4_acls(ctx, &xattr, &xlen) != 0) {
+             kfree(isec);
+             return -ENOMEM;
+         }
+     }
+     isec->xattr = xattr;
+     isec->size = xlen;
+ 
+ 	perm->security = isec;
+ 	return 0;
+ }
+ 
+ static void ipc_free_security(struct kern_ipc_perm *perm)
+ {
+ 	dcac_ipc_sec_t *isec = perm->security;
+ 
+     if (isec->xattr)
+         kfree(isec->xattr);
+     kfree(isec);
+     perm->security = NULL;
+ }
+ 
+ 
+ /* ----------------------------- */
+ /* Shared Memory security operations */
+ static int dcac_shm_alloc_security(struct shmid_kernel *shp)
+ {
+ 	return ipc_alloc_security(current_dcac_task_ctx(), &shp->shm_perm);
+ }
+ 
+ static void dcac_shm_free_security(struct shmid_kernel *shp)
+ {
+ 	ipc_free_security(&shp->shm_perm);
+ }
+ 
+ static int dcac_shm_associate(struct shmid_kernel *shp, int shmflg)
+ {
+     return dcac_ipc_permission(&shp->shm_perm, MAY_READ);
+ }
+ 
+ /* Note, at this point, shp is locked down */
+ static int dcac_shm_shmctl(struct shmid_kernel *shp, int cmd)
+ {
+     void *p;
+     char *rdacl, *wracl, *exacl, *mdacl;
+     int rdlen, wrlen, exlen, mdlen;
+     int size, ret;
+ 	dcac_ipc_sec_t *isec = shp->shm_perm.security;
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+ 
+     if ((ctx->mode_mask & DCAC_PMASK_OWNERSHIP) != 0)
+         return 0;
+     p = isec->xattr;
+     size = isec->size;
+     p = dcac_next_acl_in_line(p, &rdacl, &rdlen, &size);
+     p = dcac_next_acl_in_line(p, &wracl, &wrlen, &size);
+     p = dcac_next_acl_in_line(p, &exacl, &exlen, &size);
+     p = dcac_next_acl_in_line(p, &mdacl, &mdlen, &size);
+ 
+     read_lock_bh(&ctx->ctx_lock);
+ 
+     switch(cmd) {
+         case IPC_RMID:
+         case IPC_SET:
+         case SHM_LOCK:
+         case SHM_UNLOCK:
+             ret = -EPERM;
+             if (dcac_check_acl(ctx, mdacl, mdlen) != 0)
+                 goto out;
+             break;
+         default:
+             break;
+     }
+ 
+     ret = 0;
+ out:
+     read_unlock_bh(&ctx->ctx_lock);
+     return ret;
+ }
+ 
+ static int dcac_shm_shmat(struct shmid_kernel *shp,
+ 			     char __user *shmaddr, int shmflg)
+ {
+     /* Note: permission already checked in dcac_ipc_permission */
+     return 0;
+ }
+ 
+ 
+ /* ----------------------------- */
+ /* Semaphore security operations */
+ static int dcac_sem_alloc_security(struct sem_array *sma)
+ {
+ 	return ipc_alloc_security(current_dcac_task_ctx(), &sma->sem_perm);
+ }
+ 
+ static void dcac_sem_free_security(struct sem_array *sma)
+ {
+ 	ipc_free_security(&sma->sem_perm);
+ }
+ 
+ static int dcac_sem_associate(struct sem_array *sma, int semflg)
+ {
+     return dcac_ipc_permission(&sma->sem_perm, MAY_READ);
+ }
+ 
+ /* Note, at this point, sma is locked down */
+ static int dcac_sem_semctl(struct sem_array *sma, int cmd)
+ {
+     void *p;
+     char *rdacl, *wracl, *exacl, *mdacl;
+     int rdlen, wrlen, exlen, mdlen;
+     int size, ret;
+ 	dcac_ipc_sec_t *isec = sma->sem_perm.security;
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+ 
+     if ((ctx->mode_mask & DCAC_PMASK_OWNERSHIP) != 0)
+         return 0;
+     p = isec->xattr;
+     size = isec->size;
+     p = dcac_next_acl_in_line(p, &rdacl, &rdlen, &size);
+     p = dcac_next_acl_in_line(p, &wracl, &wrlen, &size);
+     p = dcac_next_acl_in_line(p, &exacl, &exlen, &size);
+     p = dcac_next_acl_in_line(p, &mdacl, &mdlen, &size);
+ 
+     read_lock_bh(&ctx->ctx_lock);
+ 
+     switch(cmd) {
+         case IPC_RMID:
+         case IPC_SET:
+             ret = -EPERM;
+             if (dcac_check_acl(ctx, mdacl, mdlen) != 0)
+                 goto out;
+             break;
+         default:
+             break;
+     }
+ 
+     ret = 0;
+ out:
+     read_unlock_bh(&ctx->ctx_lock);
+     return ret;
+ }
+ 
+ static int dcac_sem_semop(struct sem_array *sma,
+ 			     struct sembuf *sops, unsigned nsops, int alter)
+ {
+     /* Note: permission already checked in dcac_ipc_permission */
+     return 0;
+ }
+ 
+ 
+ /* message queue security operations */
+ static int dcac_msg_queue_alloc_security(struct msg_queue *msq)
+ {
+ 	return ipc_alloc_security(current_dcac_task_ctx(), &msq->q_perm);
+ }
+ 
+ static void dcac_msg_queue_free_security(struct msg_queue *msq)
+ {
+ 	ipc_free_security(&msq->q_perm);
+ }
+ 
+ static int dcac_msg_queue_associate(struct msg_queue *msq, int msqflg)
+ {
+     return dcac_ipc_permission(&msq->q_perm, MAY_READ);
+ }
+ 
+ static int dcac_msg_queue_msgctl(struct msg_queue *msq, int cmd)
+ {
+     void *p;
+     char *rdacl, *wracl, *exacl, *mdacl;
+     int rdlen, wrlen, exlen, mdlen;
+     int size, ret;
+ 	dcac_ipc_sec_t *isec = msq->q_perm.security;
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+ 
+     if ((ctx->mode_mask & DCAC_PMASK_OWNERSHIP) != 0)
+         return 0;
+     p = isec->xattr;
+     size = isec->size;
+     p = dcac_next_acl_in_line(p, &rdacl, &rdlen, &size);
+     p = dcac_next_acl_in_line(p, &wracl, &wrlen, &size);
+     p = dcac_next_acl_in_line(p, &exacl, &exlen, &size);
+     p = dcac_next_acl_in_line(p, &mdacl, &mdlen, &size);
+ 
+     read_lock_bh(&ctx->ctx_lock);
+ 
+     switch(cmd) {
+         case IPC_RMID:
+         case IPC_SET:
+             ret = -EPERM;
+             if (dcac_check_acl(ctx, mdacl, mdlen) != 0)
+                 goto out;
+             break;
+         default:
+             break;
+     }
+ 
+     ret = 0;
+ out:
+     read_unlock_bh(&ctx->ctx_lock);
+     return ret;
+ }
+ 
+ static int dcac_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg, int msqflg)
+ {
+     /* Note: permission already checked in dcac_ipc_permission */
+     return 0;
+ }
+ 
+ static int dcac_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
+ 				    struct task_struct *target,
+ 				    long type, int mode)
+ {
+     /* Note: permission already checked in dcac_ipc_permission */
+     return 0;
+ }
+ 
+ static struct security_operations dcac_ops = {
+     .name =             "dcac",
+ 
+     .ptrace_access_check =      dcac_ptrace_access_check,
+     .ptrace_traceme =       dcac_ptrace_traceme,
+     .task_kill  =       dcac_task_kill,
+     .capable =          dcac_capable,
+ 
+     .path_chmod =           dcac_path_chmod,
+     .inode_setxattr =       dcac_inode_setxattr,
+     .inode_removexattr =    dcac_inode_removexattr,
+     .inode_permission =             dcac_inode_permission,
+     .inode_alloc_security =         dcac_inode_alloc_security,
+     .inode_free_security =          dcac_inode_free_security,
+ 
+     .inode_init_security =  dcac_inode_init_security,
+     .inode_setsecctx = dcac_inode_setsecctx,
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+ 	.inode_post_setxattr =		dcac_inode_post_setxattr,
+ 	.inode_setsecurity =		dcac_inode_setsecurity,
+     .inode_notifysecctx =       dcac_inode_notifysecctx,
+ 	.d_instantiate =		    dcac_d_instantiate,
+ #endif
+ 
+     .mmap_addr =            cap_mmap_addr,
+ 
+     .cred_alloc_blank =     dcac_cred_alloc_blank,
+     .cred_free =            dcac_cred_free,
+     .cred_prepare =         dcac_cred_prepare,
+     .cred_transfer =        dcac_cred_transfer,
+ 
+     .ipc_permission =       dcac_ipc_permission,
+     .shm_alloc_security =   dcac_shm_alloc_security,
+     .shm_free_security =    dcac_shm_free_security,
+     .shm_associate =        dcac_shm_associate,
+     .shm_shmctl =           dcac_shm_shmctl,
+     .shm_shmat =            dcac_shm_shmat,
+ 
+     .sem_alloc_security =   dcac_sem_alloc_security,
+     .sem_free_security =    dcac_sem_free_security,
+     .sem_associate =        dcac_sem_associate,
+     .sem_semctl =           dcac_sem_semctl,
+     .sem_semop =            dcac_sem_semop,
+ 
+     .msg_queue_alloc_security =   dcac_msg_queue_alloc_security,
+     .msg_queue_free_security =    dcac_msg_queue_free_security,
+     .msg_queue_associate =        dcac_msg_queue_associate,
+     .msg_queue_msgctl =           dcac_msg_queue_msgctl,
+     .msg_queue_msgrcv =           dcac_msg_queue_msgrcv,
+     .msg_queue_msgsnd =           dcac_msg_queue_msgsnd,
+ };
+ 
+ /*
+  * DCAC init functions
+  */
+ 
+ /**
+  * set_init_ctx - set a task context on the first task.
+  */
+ static int __init set_init_ctx(void)
+ {
+     struct cred *cred = (struct cred *)current->real_cred;
+     struct dcac_task_ctx *ctx;
+ 
+     ctx = dcac_alloc_task_ctx(GFP_KERNEL);
+     if (ctx == NULL)
+         return -ENOMEM;
+ 
+ #ifdef CONFIG_SECURITY_DCAC_INODE_CACHE
+     dcac_inode_cache = kmem_cache_create("dcac_inode_security",
+             sizeof(dcac_inode_sec_t), 0, SLAB_PANIC, NULL);
+ #endif
+ 
+     cred->security = ctx;
+ 
+     return 0;
+ }
+ 
+ static int __init dcac_init(void)
+ {
+     int error = 0;
+ 
+     error = set_init_ctx();
+     if (error) {
+         DCAC_ERROR("Failed to set context on init task\n");
+         printk(KERN_EMERG "DCAC: Failed to set context on init.\n");
+         goto alloc_out;
+     }
+ 
+     error = register_security(&dcac_ops);
+     if (error) {
+         DCAC_ERROR("Unable to register DCAC LSM\n");
+         printk(KERN_EMERG "DCAC: kernel registration failed.\n");
+         goto set_init_ctx_out;
+     }
+ 
+     /* Report that DCAC successfully initialized */
+     dcac_initialized = 1;
+     dcac_info_message("DCAC initialized");
+ 
+     return error;
+ 
+ set_init_ctx_out:
+     dcac_free_task_ctx(current->real_cred->security);
+ 
+ alloc_out:
+ 
+     return error;
+ }
+ 
+ security_initcall(dcac_init);
diff -crN orig/linux-3.5.4/security/dcac/Makefile linux-3.5.4/security/dcac/Makefile
*** orig/linux-3.5.4/security/dcac/Makefile	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/Makefile	2014-01-20 15:45:10.353335931 -0600
***************
*** 0 ****
--- 1,5 ----
+ # Makefile for DCAC Linux Security Module
+ 
+ obj-$(CONFIG_SECURITY_DCAC) += dcac.o
+ 
+ dcac-y := lsm.o file.o context.o hash.o inode_perm.o acl.o syscall.o
diff -crN orig/linux-3.5.4/security/dcac/syscall.c linux-3.5.4/security/dcac/syscall.c
*** orig/linux-3.5.4/security/dcac/syscall.c	1969-12-31 18:00:00.000000000 -0600
--- linux-3.5.4/security/dcac/syscall.c	2014-04-20 17:22:26.700693108 -0500
***************
*** 0 ****
--- 1,302 ----
+ #include <linux/fs.h>
+ #include <linux/fdtable.h>
+ #include <linux/namei.h>
+ #include <linux/syscalls.h>
+ #include <linux/types.h>
+ #include <linux/mount.h>
+ #include <asm/uaccess.h>
+ 
+ #include "include/acl.h"
+ #include "include/context.h"
+ #include "include/dcac.h"
+ #include "include/file.h"
+ 
+ SYSCALL_DEFINE4(dcac_add_ops, int, optype, int, gid, const char __user *, attr,
+         int, flags)
+ {
+     int ret = -EINVAL;
+     char *tmp;
+     switch(optype) {
+         case DCAC_OP_ADD_UNAME:
+             ret = dcac_add_uname_attr(flags);
+             break;
+         case DCAC_OP_ADD_GNAME:
+             ret = dcac_add_gname_attr(gid);
+             break;
+         case DCAC_OP_ADD_ANY:
+             tmp = getname(attr);
+             ret = dcac_add_any_attr(tmp, flags);
+             putname(tmp);
+             break;
+     }
+     return ret;
+ }
+ 
+ SYSCALL_DEFINE5(dcac_acl_ops, int, optype, int, afd, int, ffd,
+         const char __user *, acl1, const char __user *, acl2_or_file)
+ {
+     int ret = -EINVAL, len1, len2, attrlen;
+     char *tmp1, *tmp2, *eacl1, *eacl2;
+     char *fname;
+     struct path path;
+     void *p;
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+     struct files_struct *files = current->files;
+     struct fdtable *fdt;
+ 
+     switch(optype) {
+         case DCAC_OP_SET_DEF_RDACL:
+         case DCAC_OP_SET_DEF_WRACL:
+         case DCAC_OP_SET_DEF_EXACL:
+         case DCAC_OP_SET_DEF_MDACL:
+             tmp1 = kmalloc(DCAC_ACL_MAX_LEN, GFP_KERNEL);
+             if (!tmp1) {
+                 ret = -ENOMEM;
+                 break;
+             }
+             if (acl1)
+                 strncpy_from_user(tmp1, acl1, DCAC_ACL_MAX_LEN);
+             else
+                 strcpy(tmp1, "");
+             eacl1 = kmalloc(DCAC_ACL_MAX_LEN, GFP_KERNEL);
+             if (!eacl1) {
+                 ret = -ENOMEM;
+                 kfree(tmp1);
+                 break;
+             }
+             len1 = dcac_encode_acl(eacl1, tmp1);
+             switch(optype) {
+                 case DCAC_OP_SET_DEF_RDACL:
+                     ret = dcac_set_default_rdacl(ctx, eacl1, len1);
+                     break;
+                 case DCAC_OP_SET_DEF_WRACL:
+                     ret = dcac_set_default_wracl(ctx, eacl1, len1);
+                     break;
+                 case DCAC_OP_SET_DEF_EXACL:
+                     ret = dcac_set_default_exacl(ctx, eacl1, len1);
+                     break;
+                 case DCAC_OP_SET_DEF_MDACL:
+                     ret = dcac_set_default_mdacl(ctx, eacl1, len1);
+                     break;
+             }
+             kfree(eacl1);
+             kfree(tmp1);
+             break;
+         case DCAC_OP_SET_ATTR_ACL:
+             spin_lock(&files->file_lock);
+             fdt = files_fdtable(files);
+             if (afd < 0 || afd >= fdt->max_fds || !fdt->fd[afd] ||
+                     ffd < 0 || ffd >= fdt->max_fds || !fdt->fd[ffd]) {
+                 spin_unlock(&files->file_lock);
+                 return -EBADF;
+             }
+             if (!DCAC_FLAGS_CAN_MOD(fdt->fd[afd]->f_flags)) {
+                 spin_unlock(&files->file_lock);
+                 return -EACCES;
+             }
+ 
+             if (!acl1 || !acl2_or_file) {
+                 spin_unlock(&files->file_lock);
+                 return -EINVAL;
+             }
+ 
+             tmp1 = kmalloc(DCAC_ACL_MAX_LEN, GFP_KERNEL);
+             if (!tmp1) {
+                 ret = -ENOMEM;
+                 break;
+             }
+             strncpy_from_user(tmp1, acl1, DCAC_ACL_MAX_LEN);
+ 
+             eacl1 = kmalloc(DCAC_ACL_MAX_LEN, GFP_KERNEL);
+             if (!eacl1) {
+                 ret = -ENOMEM;
+                 kfree(tmp1);
+                 spin_unlock(&files->file_lock);
+                 break;
+             }
+             tmp2 = kmalloc(DCAC_ACL_MAX_LEN, GFP_KERNEL);
+             if (!tmp2) {
+                 kfree(tmp1);
+                 kfree(eacl1);
+                 ret = -ENOMEM;
+                 break;
+             }
+             strncpy_from_user(tmp2, acl2_or_file, DCAC_ACL_MAX_LEN);
+ 
+             eacl2 = kmalloc(DCAC_ACL_MAX_LEN, GFP_KERNEL);
+             if (!eacl2) {
+                 ret = -ENOMEM;
+                 kfree(tmp1);
+                 kfree(tmp2);
+                 kfree(eacl1);
+                 spin_unlock(&files->file_lock);
+                 break;
+             }
+             len1 = dcac_encode_acl(eacl1, tmp1);
+             kfree(tmp1);
+             len2 = dcac_encode_acl(eacl2, tmp2);
+             kfree(tmp2);
+ 
+             tmp1 = kmalloc(4096, GFP_KERNEL);
+             if (!tmp1) {
+                 ret = -ENOMEM;
+                 kfree(eacl1);
+                 kfree(eacl2);
+                 spin_unlock(&files->file_lock);
+                 break;
+             }
+             p = tmp1;
+             attrlen = strlen((char *)fdt->fd[afd]->private_data);
+             *(uint16_t *)p = attrlen;
+             p += sizeof(uint16_t);
+             memcpy(p, fdt->fd[afd]->private_data, attrlen);
+             p += attrlen;
+             *(uint16_t *)p = len1;
+             p += sizeof(uint16_t);
+             memcpy(p, eacl1, len1);
+             p += len1;
+             *(uint16_t *)p = len2;
+             p += sizeof(uint16_t);
+             memcpy(p, eacl2, len2);
+             p += len2;
+  
+             ret = dcac_setxattr(fdt->fd[ffd]->f_dentry, NULL,
+                     DCAC_FATTR_NAME_AT, tmp1, (size_t)(p - (void *)tmp1));
+             spin_unlock(&files->file_lock);
+             break;
+         case DCAC_OP_SET_FILE_RDACL:
+         case DCAC_OP_SET_FILE_WRACL:
+         case DCAC_OP_SET_FILE_EXACL:
+         case DCAC_OP_SET_FILE_MDACL:
+             if (!acl2_or_file)
+                 return -EINVAL;
+             fname = getname(acl2_or_file);
+             if (!fname)
+                 return -EINVAL;
+             ret = kern_path(fname, 0, &path);
+             putname(fname);
+             if (ret)
+                 return -EINVAL;
+             ret = mnt_want_write(path.mnt);
+             if (ret)
+                 goto out_pput;
+ 
+             tmp1 = kmalloc(DCAC_ACL_MAX_LEN, GFP_KERNEL);
+             if (!tmp1) {
+                 ret = -ENOMEM;
+                 goto out_pput;
+             }
+             strncpy_from_user(tmp1, acl1, DCAC_ACL_MAX_LEN);
+             eacl1 = kmalloc(DCAC_ACL_MAX_LEN, GFP_KERNEL);
+             if (!eacl1) {
+                 ret = -ENOMEM;
+                 goto out_free;
+             }
+             len1 = dcac_encode_acl(eacl1, tmp1);
+             switch(optype) {
+                 case DCAC_OP_SET_FILE_RDACL:
+                     ret = dcac_set_file_acl(ctx, path.dentry,
+                             0, eacl1, len1);
+                     break;
+                 case DCAC_OP_SET_FILE_WRACL:
+                     ret = dcac_set_file_acl(ctx, path.dentry,
+                             1, eacl1, len1);
+                     break;
+                 case DCAC_OP_SET_FILE_EXACL:
+                     ret = dcac_set_file_acl(ctx, path.dentry,
+                             2, eacl1, len1);
+                     break;
+                 case DCAC_OP_SET_FILE_MDACL:
+                     ret = dcac_set_file_acl(ctx, path.dentry,
+                             3, eacl1, len1);
+                     break;
+             }
+             kfree(eacl1);
+ out_free:
+             kfree(tmp1);
+ out_pput:
+             mnt_drop_write(path.mnt);
+             path_put(&path);
+             break;
+     }
+ 
+     return ret;
+ }
+ 
+ 
+ SYSCALL_DEFINE2(dcac_mask_ops, int, optype, int, mask)
+ {
+     int ret = -EINVAL;
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+     switch(optype) {
+         case DCAC_OP_GET_MASK:
+             ret = ctx->mode_mask;
+             break;
+         case DCAC_OP_SET_MASK:
+             dcac_restrict_mask(ctx, mask);
+             ret = 0;
+             break;
+         case DCAC_OP_LOCKDOWN:
+             ctx->fixed = true;
+             ret = 0;
+             break;
+         case DCAC_OP_UNLOCK:
+             ctx->fixed = false;
+             ret = 0;
+             break;
+     }
+ 
+     return ret;
+ }
+ 
+ SYSCALL_DEFINE5(dcac_info_ops, int, optype, int, fd,
+         const char __user *, attr, void __user *, buf, int, bufsize)
+ {
+     int ret = -EINVAL, i;
+     char *tmp;
+     dcac_task_ctx_t *ctx = current_dcac_task_ctx();
+     struct files_struct *files = current->files;
+     struct fdtable *fdt;
+ 
+     switch(optype) {
+         case DCAC_OP_GET_ATTR_FD:
+             tmp = getname(attr);
+ 
+             ret = dcac_find_attr_plain(ctx, tmp, strlen(tmp));
+             if (ret >= 0)
+                 ret = ctx->attr_array[ret].fd;
+             putname(tmp);
+             break;
+         case DCAC_OP_GET_ATTR_NAME:
+             spin_lock(&files->file_lock);
+             fdt = files_fdtable(files);
+             if (fd < 0 || fd >= fdt->max_fds || !fdt->fd[fd] ||
+                     !DCAC_FLAGS_CAN_ADD(fdt->fd[fd]->f_flags) ||
+                     !fdt->fd[fd]->private_data) {
+                 spin_unlock(&files->file_lock);
+                 return -ENODATA;
+             }
+             ret = strlen((char *)fdt->fd[fd]->private_data);
+             if (ret + 1 > bufsize)
+               return -ERANGE;
+             copy_to_user(buf, fdt->fd[fd]->private_data, ret);
+             copy_to_user(buf + ret, "\0", 1);
+ 
+             spin_unlock(&files->file_lock);
+             ret = 0;
+             break;
+         case DCAC_OP_GET_ATTR_FD_LIST:
+             if (bufsize < ctx->n_attrs)
+               return -ERANGE;
+             i = 0;
+             for (; i < ctx->n_attrs; i++) {
+                 copy_to_user(buf + i * sizeof(int),
+                         &ctx->attr_array[i].fd,
+                         sizeof(int));
+             }
+             ret = ctx->n_attrs;
+             break;
+     }
+ 
+     return ret;
+ }
diff -crN orig/linux-3.5.4/security/Kconfig linux-3.5.4/security/Kconfig
*** orig/linux-3.5.4/security/Kconfig	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/security/Kconfig	2012-11-04 16:24:35.400305835 -0600
***************
*** 122,127 ****
--- 122,128 ----
  source security/tomoyo/Kconfig
  source security/apparmor/Kconfig
  source security/yama/Kconfig
+ source security/dcac/Kconfig
  
  source security/integrity/Kconfig
  
***************
*** 132,137 ****
--- 133,139 ----
  	default DEFAULT_SECURITY_TOMOYO if SECURITY_TOMOYO
  	default DEFAULT_SECURITY_APPARMOR if SECURITY_APPARMOR
  	default DEFAULT_SECURITY_YAMA if SECURITY_YAMA
+ 	default DEFAULT_SECURITY_DCAC if SECURITY_DCAC
  	default DEFAULT_SECURITY_DAC
  
  	help
***************
*** 153,158 ****
--- 155,163 ----
  	config DEFAULT_SECURITY_YAMA
  		bool "Yama" if SECURITY_YAMA=y
  
+ 	config DEFAULT_SECURITY_DCAC
+ 		bool "DCAC" if SECURITY_DCAC=y
+ 
  	config DEFAULT_SECURITY_DAC
  		bool "Unix Discretionary Access Controls"
  
***************
*** 165,170 ****
--- 170,176 ----
  	default "tomoyo" if DEFAULT_SECURITY_TOMOYO
  	default "apparmor" if DEFAULT_SECURITY_APPARMOR
  	default "yama" if DEFAULT_SECURITY_YAMA
+ 	default "dcac" if DEFAULT_SECURITY_DCAC
  	default "" if DEFAULT_SECURITY_DAC
  
  endmenu
diff -crN orig/linux-3.5.4/security/Makefile linux-3.5.4/security/Makefile
*** orig/linux-3.5.4/security/Makefile	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/security/Makefile	2012-11-04 15:59:13.520353479 -0600
***************
*** 8,13 ****
--- 8,14 ----
  subdir-$(CONFIG_SECURITY_TOMOYO)        += tomoyo
  subdir-$(CONFIG_SECURITY_APPARMOR)	+= apparmor
  subdir-$(CONFIG_SECURITY_YAMA)		+= yama
+ subdir-$(CONFIG_SECURITY_DCAC)		+= dcac
  
  # always enable default capabilities
  obj-y					+= commoncap.o
***************
*** 22,27 ****
--- 23,29 ----
  obj-$(CONFIG_AUDIT)			+= lsm_audit.o
  obj-$(CONFIG_SECURITY_TOMOYO)		+= tomoyo/built-in.o
  obj-$(CONFIG_SECURITY_APPARMOR)		+= apparmor/built-in.o
+ obj-$(CONFIG_SECURITY_DCAC)		+= dcac/built-in.o
  obj-$(CONFIG_SECURITY_YAMA)		+= yama/built-in.o
  obj-$(CONFIG_CGROUP_DEVICE)		+= device_cgroup.o
  
diff -crN orig/linux-3.5.4/security/selinux/hooks.c linux-3.5.4/security/selinux/hooks.c
*** orig/linux-3.5.4/security/selinux/hooks.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/security/selinux/hooks.c	2014-01-20 15:48:09.281333672 -0600
***************
*** 48,53 ****
--- 48,54 ----
  #include <linux/mount.h>
  #include <linux/netfilter_ipv4.h>
  #include <linux/netfilter_ipv6.h>
+ #include <linux/nfs_fs.h>	/* for nfs_server_capable() */
  #include <linux/tty.h>
  #include <net/icmp.h>
  #include <net/ip.h>		/* for local_port_range[] */
***************
*** 554,560 ****
  				struct security_mnt_opts *opts)
  {
  	const struct cred *cred = current_cred();
! 	int rc = 0, i;
  	struct superblock_security_struct *sbsec = sb->s_security;
  	const char *name = sb->s_type->name;
  	struct inode *inode = sbsec->sb->s_root->d_inode;
--- 555,561 ----
  				struct security_mnt_opts *opts)
  {
  	const struct cred *cred = current_cred();
! 	int rc = 0, use_xattr = 0, i;
  	struct superblock_security_struct *sbsec = sb->s_security;
  	const char *name = sb->s_type->name;
  	struct inode *inode = sbsec->sb->s_root->d_inode;
***************
*** 669,679 ****
  	if (strcmp(sb->s_type->name, "proc") == 0)
  		sbsec->flags |= SE_SBPROC;
  
  	/* Determine the labeling behavior to use for this filesystem type. */
! 	rc = security_fs_use((sbsec->flags & SE_SBPROC) ? "proc" : sb->s_type->name, &sbsec->behavior, &sbsec->sid);
  	if (rc) {
! 		printk(KERN_WARNING "%s: security_fs_use(%s) returned %d\n",
! 		       __func__, sb->s_type->name, rc);
  		goto out;
  	}
  
--- 670,701 ----
  	if (strcmp(sb->s_type->name, "proc") == 0)
  		sbsec->flags |= SE_SBPROC;
  
+ 	/*
+ 	 * Special handling for NFSv3: if the xattrsec mount option was
+ 	 * specified, check to see if the XATTR protocol is supported, and
+ 	 * if so, require SECURITY_FS_USE_XATTR behavior.
+ 	 */
+ 	if (!strcmp(sb->s_type->name, "nfs")) {
+ 		if (nfs_server_xattrsec(inode)) {
+ 			if (nfs_server_capable(inode, NFS_CAP_XATTR))
+ 				use_xattr = 1;
+ 			else {
+ 				printk(KERN_WARNING "SELinux: xattrsec "
+ 				       "specified but XATTR unsupported\n");
+ 				rc = -EOPNOTSUPP;
+ 				goto out;
+ 			}
+ 		}
+ 	}
+ 
  	/* Determine the labeling behavior to use for this filesystem type. */
! 	rc = security_fs_use((sbsec->flags & SE_SBPROC) ?
! 			     "proc" : sb->s_type->name, &sbsec->behavior,
! 			     &sbsec->sid, use_xattr);
  	if (rc) {
! 		printk(KERN_WARNING "%s: security_fs_use(%s) (use_xattr=%d) "
! 		       "returned %d\n", __func__, sb->s_type->name,
! 		       use_xattr, rc);
  		goto out;
  	}
  
***************
*** 1251,1257 ****
  						   context, len);
  		}
  		dput(dentry);
! 		if (rc < 0) {
  			if (rc != -ENODATA) {
  				printk(KERN_WARNING "SELinux: %s:  getxattr returned "
  				       "%d for dev=%s ino=%ld\n", __func__,
--- 1273,1279 ----
  						   context, len);
  		}
  		dput(dentry);
! 		if (rc <= 0) {
  			if (rc != -ENODATA) {
  				printk(KERN_WARNING "SELinux: %s:  getxattr returned "
  				       "%d for dev=%s ino=%ld\n", __func__,
diff -crN orig/linux-3.5.4/security/selinux/include/security.h linux-3.5.4/security/selinux/include/security.h
*** orig/linux-3.5.4/security/selinux/include/security.h	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/security/selinux/include/security.h	2014-01-20 15:48:09.281333672 -0600
***************
*** 171,177 ****
  #define SECURITY_FS_USE_MNTPOINT	6 /* use mountpoint labeling */
  
  int security_fs_use(const char *fstype, unsigned int *behavior,
! 	u32 *sid);
  
  int security_genfs_sid(const char *fstype, char *name, u16 sclass,
  	u32 *sid);
--- 171,177 ----
  #define SECURITY_FS_USE_MNTPOINT	6 /* use mountpoint labeling */
  
  int security_fs_use(const char *fstype, unsigned int *behavior,
! 	u32 *sid, int use_xattr);
  
  int security_genfs_sid(const char *fstype, char *name, u16 sclass,
  	u32 *sid);
diff -crN orig/linux-3.5.4/security/selinux/ss/services.c linux-3.5.4/security/selinux/ss/services.c
*** orig/linux-3.5.4/security/selinux/ss/services.c	2012-09-14 17:28:08.000000000 -0500
--- linux-3.5.4/security/selinux/ss/services.c	2014-01-20 15:48:09.281333672 -0600
***************
*** 2326,2336 ****
   * @fstype: filesystem type
   * @behavior: labeling behavior
   * @sid: SID for filesystem (superblock)
   */
  int security_fs_use(
  	const char *fstype,
  	unsigned int *behavior,
! 	u32 *sid)
  {
  	int rc = 0;
  	struct ocontext *c;
--- 2326,2337 ----
   * @fstype: filesystem type
   * @behavior: labeling behavior
   * @sid: SID for filesystem (superblock)
+  * @use_xattr: use xattr labeling behavior for NFS
   */
  int security_fs_use(
  	const char *fstype,
  	unsigned int *behavior,
! 	u32 *sid, int use_xattr)
  {
  	int rc = 0;
  	struct ocontext *c;
***************
*** 2339,2346 ****
  
  	c = policydb.ocontexts[OCON_FSUSE];
  	while (c) {
! 		if (strcmp(fstype, c->u.name) == 0)
! 			break;
  		c = c->next;
  	}
  
--- 2340,2358 ----
  
  	c = policydb.ocontexts[OCON_FSUSE];
  	while (c) {
! 		/*
! 		 * Without significant redesign, we need to add a special
! 		 * case for NFS here.  TODO: consider using the new 'native'
! 		 * labeling behavior from LNFS.
! 		 */
! 		if (strcmp(fstype, c->u.name) == 0) {
! 			if (strcmp(fstype, "nfs") == 0) {
! 				if (use_xattr &&
! 				    (c->v.behavior == SECURITY_FS_USE_XATTR))
! 					break;
! 			} else
! 				break;
! 		}
  		c = c->next;
  	}
  
***************
*** 2354,2359 ****
--- 2366,2376 ----
  		}
  		*sid = c->sid[0];
  	} else {
+ 		if (use_xattr) {
+ 			/* xattr required, must not fall back to genfs */
+ 			rc = -EINVAL;
+ 			goto out;
+ 		}
  		rc = security_genfs_sid(fstype, "/", SECCLASS_DIR, sid);
  		if (rc) {
  			*behavior = SECURITY_FS_USE_NONE;
